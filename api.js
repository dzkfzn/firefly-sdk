"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v6.2.21
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2025-07-18T05:50:30+00:00 Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that.
 *
 * The version of the OpenAPI document: v6.2.21
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvailableBudgetsApi = exports.AvailableBudgetsApiFactory = exports.AvailableBudgetsApiFp = exports.AvailableBudgetsApiAxiosParamCreator = exports.AutocompleteApi = exports.AutocompleteApiFactory = exports.AutocompleteApiFp = exports.AutocompleteApiAxiosParamCreator = exports.AttachmentsApi = exports.AttachmentsApiFactory = exports.AttachmentsApiFp = exports.AttachmentsApiAxiosParamCreator = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.AboutApi = exports.AboutApiFactory = exports.AboutApiFp = exports.AboutApiAxiosParamCreator = exports.WebhookTrigger = exports.WebhookResponse = exports.WebhookDelivery = exports.UserRoleProperty = exports.UserGroupReadRole = exports.UserBlockedCodeProperty = exports.TransactionTypeProperty = exports.TransactionTypeFilter = exports.ShortAccountTypeProperty = exports.RuleTriggerType = exports.RuleTriggerKeyword = exports.RuleActionKeyword = exports.RecurrenceTransactionType = exports.RecurrenceRepetitionType = exports.LiabilityTypeProperty = exports.LiabilityDirectionProperty = exports.InterestPeriodProperty = exports.ExportFileFilter = exports.DataDestroyObject = exports.CreditCardTypeProperty = exports.ConfigValueUpdateFilter = exports.ConfigValueFilter = exports.BillRepeatFrequency = exports.AutoBudgetType = exports.AutoBudgetPeriod = exports.AttachableType = exports.AccountTypeProperty = exports.AccountTypeFilter = exports.AccountSearchFieldFilter = exports.AccountRoleProperty = void 0;
exports.PreferencesApiFp = exports.PreferencesApiAxiosParamCreator = exports.PiggyBanksApi = exports.PiggyBanksApiFactory = exports.PiggyBanksApiFp = exports.PiggyBanksApiAxiosParamCreator = exports.ObjectGroupsApi = exports.ObjectGroupsApiFactory = exports.ObjectGroupsApiFp = exports.ObjectGroupsApiAxiosParamCreator = exports.LinksApi = exports.LinksApiFactory = exports.LinksApiFp = exports.LinksApiAxiosParamCreator = exports.InsightApi = exports.InsightApiFactory = exports.InsightApiFp = exports.InsightApiAxiosParamCreator = exports.DataApi = exports.DataApiFactory = exports.DataApiFp = exports.DataApiAxiosParamCreator = exports.CurrencyExchangeRatesApi = exports.CurrencyExchangeRatesApiFactory = exports.CurrencyExchangeRatesApiFp = exports.CurrencyExchangeRatesApiAxiosParamCreator = exports.CurrenciesApi = exports.CurrenciesApiFactory = exports.CurrenciesApiFp = exports.CurrenciesApiAxiosParamCreator = exports.ConfigurationApi = exports.ConfigurationApiFactory = exports.ConfigurationApiFp = exports.ConfigurationApiAxiosParamCreator = exports.ChartsApi = exports.ChartsApiFactory = exports.ChartsApiFp = exports.ChartsApiAxiosParamCreator = exports.CategoriesApi = exports.CategoriesApiFactory = exports.CategoriesApiFp = exports.CategoriesApiAxiosParamCreator = exports.BudgetsApi = exports.BudgetsApiFactory = exports.BudgetsApiFp = exports.BudgetsApiAxiosParamCreator = exports.BillsApi = exports.BillsApiFactory = exports.BillsApiFp = exports.BillsApiAxiosParamCreator = void 0;
exports.WebhooksApi = exports.WebhooksApiFactory = exports.WebhooksApiFp = exports.WebhooksApiAxiosParamCreator = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.UserGroupsApi = exports.UserGroupsApiFactory = exports.UserGroupsApiFp = exports.UserGroupsApiAxiosParamCreator = exports.TransactionsApi = exports.TransactionsApiFactory = exports.TransactionsApiFp = exports.TransactionsApiAxiosParamCreator = exports.TagsApi = exports.TagsApiFactory = exports.TagsApiFp = exports.TagsApiAxiosParamCreator = exports.SummaryApi = exports.SummaryApiFactory = exports.SummaryApiFp = exports.SummaryApiAxiosParamCreator = exports.SearchApi = exports.SearchApiFactory = exports.SearchApiFp = exports.SearchApiAxiosParamCreator = exports.RulesApi = exports.RulesApiFactory = exports.RulesApiFp = exports.RulesApiAxiosParamCreator = exports.RuleGroupsApi = exports.RuleGroupsApiFactory = exports.RuleGroupsApiFp = exports.RuleGroupsApiAxiosParamCreator = exports.RecurrencesApi = exports.RecurrencesApiFactory = exports.RecurrencesApiFp = exports.RecurrencesApiAxiosParamCreator = exports.PreferencesApi = exports.PreferencesApiFactory = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * Is only mandatory when the type is asset.
 * @export
 * @enum {string}
 */
exports.AccountRoleProperty = {
    DefaultAsset: 'defaultAsset',
    SharedAsset: 'sharedAsset',
    SavingAsset: 'savingAsset',
    CcAsset: 'ccAsset',
    CashWalletAsset: 'cashWalletAsset'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.AccountSearchFieldFilter = {
    All: 'all',
    Iban: 'iban',
    Name: 'name',
    Number: 'number',
    Id: 'id'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.AccountTypeFilter = {
    All: 'all',
    Asset: 'asset',
    Cash: 'cash',
    Expense: 'expense',
    Revenue: 'revenue',
    Special: 'special',
    Hidden: 'hidden',
    Liability: 'liability',
    Liabilities: 'liabilities',
    DefaultAccount: 'Default account',
    CashAccount: 'Cash account',
    AssetAccount: 'Asset account',
    ExpenseAccount: 'Expense account',
    RevenueAccount: 'Revenue account',
    InitialBalanceAccount: 'Initial balance account',
    BeneficiaryAccount: 'Beneficiary account',
    ImportAccount: 'Import account',
    ReconciliationAccount: 'Reconciliation account',
    Loan: 'Loan',
    Debt: 'Debt',
    Mortgage: 'Mortgage'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.AccountTypeProperty = {
    DefaultAccount: 'Default account',
    CashAccount: 'Cash account',
    AssetAccount: 'Asset account',
    ExpenseAccount: 'Expense account',
    RevenueAccount: 'Revenue account',
    InitialBalanceAccount: 'Initial balance account',
    BeneficiaryAccount: 'Beneficiary account',
    ImportAccount: 'Import account',
    ReconciliationAccount: 'Reconciliation account',
    Loan: 'Loan',
    Debt: 'Debt',
    Mortgage: 'Mortgage'
};
/**
 * The object class to which the attachment must be linked.
 * @export
 * @enum {string}
 */
exports.AttachableType = {
    Account: 'Account',
    Budget: 'Budget',
    Bill: 'Bill',
    TransactionJournal: 'TransactionJournal',
    PiggyBank: 'PiggyBank',
    Tag: 'Tag'
};
/**
 * Period for the auto budget
 * @export
 * @enum {string}
 */
exports.AutoBudgetPeriod = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    HalfYear: 'half-year',
    Yearly: 'yearly'
};
/**
 * The type of auto-budget that Firefly III must create.
 * @export
 * @enum {string}
 */
exports.AutoBudgetType = {
    Reset: 'reset',
    Rollover: 'rollover',
    None: 'none'
};
/**
 * How often the bill must be paid.
 * @export
 * @enum {string}
 */
exports.BillRepeatFrequency = {
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    HalfYear: 'half-year',
    Yearly: 'yearly'
};
/**
 * Title of the configuration value.
 * @export
 * @enum {string}
 */
exports.ConfigValueFilter = {
    ConfigurationIsDemoSite: 'configuration.is_demo_site',
    ConfigurationPermissionUpdateCheck: 'configuration.permission_update_check',
    ConfigurationLastUpdateCheck: 'configuration.last_update_check',
    ConfigurationSingleUserMode: 'configuration.single_user_mode',
    FireflyVersion: 'firefly.version',
    FireflyDefaultLocation: 'firefly.default_location',
    FireflyAccountToTransaction: 'firefly.account_to_transaction',
    FireflyAllowedOpposingTypes: 'firefly.allowed_opposing_types',
    FireflyAccountRoles: 'firefly.accountRoles',
    FireflyValidLiabilities: 'firefly.valid_liabilities',
    FireflyInterestPeriods: 'firefly.interest_periods',
    FireflyEnableExternalMap: 'firefly.enable_external_map',
    FireflyExpectedSourceTypes: 'firefly.expected_source_types',
    AppTimezone: 'app.timezone',
    FireflyBillPeriods: 'firefly.bill_periods',
    FireflyCreditCardTypes: 'firefly.credit_card_types',
    FireflyLanguages: 'firefly.languages',
    FireflyValidViewRanges: 'firefly.valid_view_ranges'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ConfigValueUpdateFilter = {
    ConfigurationIsDemoSite: 'configuration.is_demo_site',
    ConfigurationPermissionUpdateCheck: 'configuration.permission_update_check',
    ConfigurationLastUpdateCheck: 'configuration.last_update_check',
    ConfigurationSingleUserMode: 'configuration.single_user_mode'
};
/**
 * Mandatory when the account_role is ccAsset. Can only be monthlyFull or null.
 * @export
 * @enum {string}
 */
exports.CreditCardTypeProperty = {
    MonthlyFull: 'monthlyFull'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.DataDestroyObject = {
    NotAssetsLiabilities: 'not_assets_liabilities',
    Budgets: 'budgets',
    Bills: 'bills',
    PiggyBanks: 'piggy_banks',
    Rules: 'rules',
    Recurring: 'recurring',
    Categories: 'categories',
    Tags: 'tags',
    ObjectGroups: 'object_groups',
    Accounts: 'accounts',
    AssetAccounts: 'asset_accounts',
    ExpenseAccounts: 'expense_accounts',
    RevenueAccounts: 'revenue_accounts',
    Liabilities: 'liabilities',
    Transactions: 'transactions',
    Withdrawals: 'withdrawals',
    Deposits: 'deposits',
    Transfers: 'transfers'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ExportFileFilter = {
    Csv: 'csv'
};
/**
 * Mandatory when type is liability. Period over which the interest is calculated.
 * @export
 * @enum {string}
 */
exports.InterestPeriodProperty = {
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    HalfYear: 'half-year',
    Yearly: 'yearly'
};
/**
 * \'credit\' indicates somebody owes you the liability. \'debit\' Indicates you owe this debt yourself. Works only for liabiltiies.
 * @export
 * @enum {string}
 */
exports.LiabilityDirectionProperty = {
    Credit: 'credit',
    Debit: 'debit'
};
/**
 * Mandatory when type is liability. Specifies the exact type.
 * @export
 * @enum {string}
 */
exports.LiabilityTypeProperty = {
    Loan: 'loan',
    Debt: 'debt',
    Mortgage: 'mortgage'
};
/**
 * The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week.
 * @export
 * @enum {string}
 */
exports.RecurrenceRepetitionType = {
    Daily: 'daily',
    Weekly: 'weekly',
    Ndom: 'ndom',
    Monthly: 'monthly',
    Yearly: 'yearly'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.RecurrenceTransactionType = {
    Withdrawal: 'withdrawal',
    Transfer: 'transfer',
    Deposit: 'deposit'
};
/**
 * The type of thing this action will do. A limited set is possible.
 * @export
 * @enum {string}
 */
exports.RuleActionKeyword = {
    UserAction: 'user_action',
    SetCategory: 'set_category',
    ClearCategory: 'clear_category',
    SetBudget: 'set_budget',
    ClearBudget: 'clear_budget',
    AddTag: 'add_tag',
    RemoveTag: 'remove_tag',
    RemoveAllTags: 'remove_all_tags',
    SetDescription: 'set_description',
    AppendDescription: 'append_description',
    PrependDescription: 'prepend_description',
    SetSourceAccount: 'set_source_account',
    SetDestinationAccount: 'set_destination_account',
    SetNotes: 'set_notes',
    AppendNotes: 'append_notes',
    PrependNotes: 'prepend_notes',
    ClearNotes: 'clear_notes',
    LinkToBill: 'link_to_bill',
    ConvertWithdrawal: 'convert_withdrawal',
    ConvertDeposit: 'convert_deposit',
    ConvertTransfer: 'convert_transfer',
    DeleteTransaction: 'delete_transaction'
};
/**
 * The type of thing this trigger responds to. A limited set is possible
 * @export
 * @enum {string}
 */
exports.RuleTriggerKeyword = {
    FromAccountStarts: 'from_account_starts',
    FromAccountEnds: 'from_account_ends',
    FromAccountIs: 'from_account_is',
    FromAccountContains: 'from_account_contains',
    ToAccountStarts: 'to_account_starts',
    ToAccountEnds: 'to_account_ends',
    ToAccountIs: 'to_account_is',
    ToAccountContains: 'to_account_contains',
    AmountLess: 'amount_less',
    AmountExactly: 'amount_exactly',
    AmountMore: 'amount_more',
    DescriptionStarts: 'description_starts',
    DescriptionEnds: 'description_ends',
    DescriptionContains: 'description_contains',
    DescriptionIs: 'description_is',
    TransactionType: 'transaction_type',
    CategoryIs: 'category_is',
    BudgetIs: 'budget_is',
    TagIs: 'tag_is',
    CurrencyIs: 'currency_is',
    HasAttachments: 'has_attachments',
    HasNoCategory: 'has_no_category',
    HasAnyCategory: 'has_any_category',
    HasNoBudget: 'has_no_budget',
    HasAnyBudget: 'has_any_budget',
    HasNoTag: 'has_no_tag',
    HasAnyTag: 'has_any_tag',
    NotesContains: 'notes_contains',
    NotesStart: 'notes_start',
    NotesEnd: 'notes_end',
    NotesAre: 'notes_are',
    NoNotes: 'no_notes',
    AnyNotes: 'any_notes',
    SourceAccountIs: 'source_account_is',
    DestinationAccountIs: 'destination_account_is',
    SourceAccountStarts: 'source_account_starts'
};
/**
 * Which action is necessary for the rule to fire? Use either store-journal or update-journal.
 * @export
 * @enum {string}
 */
exports.RuleTriggerType = {
    StoreJournal: 'store-journal',
    UpdateJournal: 'update-journal'
};
/**
 * Can only be one one these account types. import, initial-balance and reconciliation cannot be set manually.
 * @export
 * @enum {string}
 */
exports.ShortAccountTypeProperty = {
    Asset: 'asset',
    Expense: 'expense',
    Import: 'import',
    Revenue: 'revenue',
    Cash: 'cash',
    Liability: 'liability',
    Liabilities: 'liabilities',
    InitialBalance: 'initial-balance',
    Reconciliation: 'reconciliation'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.TransactionTypeFilter = {
    All: 'all',
    Withdrawal: 'withdrawal',
    Withdrawals: 'withdrawals',
    Expense: 'expense',
    Deposit: 'deposit',
    Deposits: 'deposits',
    Income: 'income',
    Transfer: 'transfer',
    Transfers: 'transfers',
    OpeningBalance: 'opening_balance',
    Reconciliation: 'reconciliation',
    Special: 'special',
    Specials: 'specials',
    Default: 'default'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.TransactionTypeProperty = {
    Withdrawal: 'withdrawal',
    Deposit: 'deposit',
    Transfer: 'transfer',
    Reconciliation: 'reconciliation',
    OpeningBalance: 'opening balance'
};
/**
 * If you say the user must be blocked, this will be the reason code.
 * @export
 * @enum {string}
 */
exports.UserBlockedCodeProperty = {
    EmailChanged: 'email_changed'
};
/**
 * The possible roles of the user in this user group are documented here: https://docs.firefly-iii.org/references/firefly-iii/api/
 * @export
 * @enum {string}
 */
exports.UserGroupReadRole = {
    Owner: 'owner',
    Ro: 'ro',
    MngTrx: 'mng_trx',
    MngMeta: 'mng_meta',
    ReadBudgets: 'read_budgets',
    ReadPiggies: 'read_piggies',
    ReadSubscriptions: 'read_subscriptions',
    ReadRules: 'read_rules',
    ReadRecurring: 'read_recurring',
    ReadWebhooks: 'read_webhooks',
    ReadCurrencies: 'read_currencies',
    MngBudgets: 'mng_budgets',
    MngPiggies: 'mng_piggies',
    MngSubscriptions: 'mng_subscriptions',
    MngRules: 'mng_rules',
    MngRecurring: 'mng_recurring',
    MngWebhooks: 'mng_webhooks',
    MngCurrencies: 'mng_currencies',
    ViewReports: 'view_reports',
    ViewMemberships: 'view_memberships',
    Full: 'full',
    Owner2: 'owner'
};
/**
 * Role for the user. Can be empty or omitted.
 * @export
 * @enum {string}
 */
exports.UserRoleProperty = {
    Owner: 'owner',
    Demo: 'demo'
};
/**
 * Format of the delivered response.
 * @export
 * @enum {string}
 */
exports.WebhookDelivery = {
    Json: 'JSON'
};
/**
 * Indicator for what Firefly III will deliver to the webhook URL.
 * @export
 * @enum {string}
 */
exports.WebhookResponse = {
    Transactions: 'TRANSACTIONS',
    Accounts: 'ACCOUNTS',
    None: 'NONE'
};
/**
 * The trigger for the webhook.
 * @export
 * @enum {string}
 */
exports.WebhookTrigger = {
    StoreTransaction: 'STORE_TRANSACTION',
    UpdateTransaction: 'UPDATE_TRANSACTION',
    DestroyTransaction: 'DESTROY_TRANSACTION'
};
/**
 * AboutApi - axios parameter creator
 * @export
 */
const AboutApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns general system information and versions of the (supporting) software.
         * @summary System information end point.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbout: (xTraceId_1, ...args_1) => __awaiter(this, [xTraceId_1, ...args_1], void 0, function* (xTraceId, options = {}) {
            const localVarPath = `/v1/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Firefly III has one endpoint for its various cron related tasks. Send a GET to this endpoint to run the cron. The cron requires the CLI token to be present. The cron job will fire for all users.
         * @summary Cron job endpoint
         * @param {string} cliToken The CLI token of any user in Firefly III, required to run the cron job.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it\&#39;s running on another day.
         * @param {boolean} [force] Forces the cron job to fire, regardless of whether it has fired before. This may result in double transactions or weird budgets, so be careful.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCron: (cliToken_1, xTraceId_1, date_1, force_1, ...args_1) => __awaiter(this, [cliToken_1, xTraceId_1, date_1, force_1, ...args_1], void 0, function* (cliToken, xTraceId, date, force, options = {}) {
            // verify required parameter 'cliToken' is not null or undefined
            (0, common_1.assertParamExists)('getCron', 'cliToken', cliToken);
            const localVarPath = `/v1/cron/{cliToken}`
                .replace(`{${"cliToken"}}`, encodeURIComponent(String(cliToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (date !== undefined) {
                localVarQueryParameter['date'] = (date instanceof Date) ?
                    date.toISOString().substring(0, 10) :
                    date;
            }
            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the currently authenticated user.
         * @summary Currently authenticated user endpoint.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: (xTraceId_1, ...args_1) => __awaiter(this, [xTraceId_1, ...args_1], void 0, function* (xTraceId, options = {}) {
            const localVarPath = `/v1/about/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AboutApiAxiosParamCreator = AboutApiAxiosParamCreator;
/**
 * AboutApi - functional programming interface
 * @export
 */
const AboutApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AboutApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns general system information and versions of the (supporting) software.
         * @summary System information end point.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbout(xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAbout(xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AboutApi.getAbout']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Firefly III has one endpoint for its various cron related tasks. Send a GET to this endpoint to run the cron. The cron requires the CLI token to be present. The cron job will fire for all users.
         * @summary Cron job endpoint
         * @param {string} cliToken The CLI token of any user in Firefly III, required to run the cron job.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it\&#39;s running on another day.
         * @param {boolean} [force] Forces the cron job to fire, regardless of whether it has fired before. This may result in double transactions or weird budgets, so be careful.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCron(cliToken, xTraceId, date, force, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCron(cliToken, xTraceId, date, force, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AboutApi.getCron']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the currently authenticated user.
         * @summary Currently authenticated user endpoint.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCurrentUser(xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AboutApi.getCurrentUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AboutApiFp = AboutApiFp;
/**
 * AboutApi - factory interface
 * @export
 */
const AboutApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AboutApiFp)(configuration);
    return {
        /**
         * Returns general system information and versions of the (supporting) software.
         * @summary System information end point.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbout(xTraceId, options) {
            return localVarFp.getAbout(xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Firefly III has one endpoint for its various cron related tasks. Send a GET to this endpoint to run the cron. The cron requires the CLI token to be present. The cron job will fire for all users.
         * @summary Cron job endpoint
         * @param {string} cliToken The CLI token of any user in Firefly III, required to run the cron job.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it\&#39;s running on another day.
         * @param {boolean} [force] Forces the cron job to fire, regardless of whether it has fired before. This may result in double transactions or weird budgets, so be careful.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCron(cliToken, xTraceId, date, force, options) {
            return localVarFp.getCron(cliToken, xTraceId, date, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the currently authenticated user.
         * @summary Currently authenticated user endpoint.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(xTraceId, options) {
            return localVarFp.getCurrentUser(xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AboutApiFactory = AboutApiFactory;
/**
 * AboutApi - object-oriented interface
 * @export
 * @class AboutApi
 * @extends {BaseAPI}
 */
class AboutApi extends base_1.BaseAPI {
    /**
     * Returns general system information and versions of the (supporting) software.
     * @summary System information end point.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AboutApi
     */
    getAbout(xTraceId, options) {
        return (0, exports.AboutApiFp)(this.configuration).getAbout(xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Firefly III has one endpoint for its various cron related tasks. Send a GET to this endpoint to run the cron. The cron requires the CLI token to be present. The cron job will fire for all users.
     * @summary Cron job endpoint
     * @param {string} cliToken The CLI token of any user in Firefly III, required to run the cron job.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [date] A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it\&#39;s running on another day.
     * @param {boolean} [force] Forces the cron job to fire, regardless of whether it has fired before. This may result in double transactions or weird budgets, so be careful.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AboutApi
     */
    getCron(cliToken, xTraceId, date, force, options) {
        return (0, exports.AboutApiFp)(this.configuration).getCron(cliToken, xTraceId, date, force, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the currently authenticated user.
     * @summary Currently authenticated user endpoint.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AboutApi
     */
    getCurrentUser(xTraceId, options) {
        return (0, exports.AboutApiFp)(this.configuration).getCurrentUser(xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AboutApi = AboutApi;
/**
 * AccountsApi - axios parameter creator
 * @export
 */
const AccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from.
         * @summary Permanently delete account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteAccount', 'id', id);
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a single account by its ID.
         * @summary Get single account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: (id_1, xTraceId_1, date_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, date_1, ...args_1], void 0, function* (id, xTraceId, date, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAccount', 'id', id);
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (date !== undefined) {
                localVarQueryParameter['date'] = (date instanceof Date) ?
                    date.toISOString().substring(0, 10) :
                    date;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint returns a list of all the accounts owned by the authenticated user.
         * @summary List all accounts.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount: (xTraceId_1, limit_1, page_1, date_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, date_1, type_1, ...args_1], void 0, function* (xTraceId, limit, page, date, type, options = {}) {
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (date !== undefined) {
                localVarQueryParameter['date'] = (date instanceof Date) ?
                    date.toISOString().substring(0, 10) :
                    date;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByAccount: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listAttachmentByAccount', 'id', id);
            const localVarPath = `/v1/accounts/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint returns a list of all the piggy banks connected to the account.
         * @summary List all piggy banks related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByAccount: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listPiggyBankByAccount', 'id', id);
            const localVarPath = `/v1/accounts/{id}/piggy-banks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint returns a list of all the transactions connected to the account.
         * @summary List all transactions related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByAccount: (id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1], void 0, function* (id, xTraceId, limit, page, start, end, type, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByAccount', 'id', id);
            const localVarPath = `/v1/accounts/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create new account.
         * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAccount: (accountStore_1, xTraceId_1, ...args_1) => __awaiter(this, [accountStore_1, xTraceId_1, ...args_1], void 0, function* (accountStore, xTraceId, options = {}) {
            // verify required parameter 'accountStore' is not null or undefined
            (0, common_1.assertParamExists)('storeAccount', 'accountStore', accountStore);
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory.
         * @summary Update existing account.
         * @param {string} id The ID of the account.
         * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: (id_1, accountUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, accountUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, accountUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateAccount', 'id', id);
            // verify required parameter 'accountUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateAccount', 'accountUpdate', accountUpdate);
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AccountsApiAxiosParamCreator = AccountsApiAxiosParamCreator;
/**
 * AccountsApi - functional programming interface
 * @export
 */
const AccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from.
         * @summary Permanently delete account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAccount(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AccountsApi.deleteAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a single account by its ID.
         * @summary Get single account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id, xTraceId, date, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccount(id, xTraceId, date, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AccountsApi.getAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint returns a list of all the accounts owned by the authenticated user.
         * @summary List all accounts.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount(xTraceId, limit, page, date, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAccount(xTraceId, limit, page, date, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AccountsApi.listAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByAccount(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAttachmentByAccount(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AccountsApi.listAttachmentByAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the account.
         * @summary List all piggy banks related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByAccount(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPiggyBankByAccount(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AccountsApi.listPiggyBankByAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint returns a list of all the transactions connected to the account.
         * @summary List all transactions related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByAccount(id, xTraceId, limit, page, start, end, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionByAccount(id, xTraceId, limit, page, start, end, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AccountsApi.listTransactionByAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create new account.
         * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAccount(accountStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeAccount(accountStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AccountsApi.storeAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory.
         * @summary Update existing account.
         * @param {string} id The ID of the account.
         * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id, accountUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAccount(id, accountUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AccountsApi.updateAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AccountsApiFp = AccountsApiFp;
/**
 * AccountsApi - factory interface
 * @export
 */
const AccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountsApiFp)(configuration);
    return {
        /**
         * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from.
         * @summary Permanently delete account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(id, xTraceId, options) {
            return localVarFp.deleteAccount(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single account by its ID.
         * @summary Get single account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id, xTraceId, date, options) {
            return localVarFp.getAccount(id, xTraceId, date, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the accounts owned by the authenticated user.
         * @summary List all accounts.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount(xTraceId, limit, page, date, type, options) {
            return localVarFp.listAccount(xTraceId, limit, page, date, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByAccount(id, xTraceId, limit, page, options) {
            return localVarFp.listAttachmentByAccount(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the account.
         * @summary List all piggy banks related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByAccount(id, xTraceId, limit, page, options) {
            return localVarFp.listPiggyBankByAccount(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the transactions connected to the account.
         * @summary List all transactions related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByAccount(id, xTraceId, limit, page, start, end, type, options) {
            return localVarFp.listTransactionByAccount(id, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create new account.
         * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAccount(accountStore, xTraceId, options) {
            return localVarFp.storeAccount(accountStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory.
         * @summary Update existing account.
         * @param {string} id The ID of the account.
         * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id, accountUpdate, xTraceId, options) {
            return localVarFp.updateAccount(id, accountUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountsApiFactory = AccountsApiFactory;
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends base_1.BaseAPI {
    /**
     * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from.
     * @summary Permanently delete account.
     * @param {string} id The ID of the account.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    deleteAccount(id, xTraceId, options) {
        return (0, exports.AccountsApiFp)(this.configuration).deleteAccount(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a single account by its ID.
     * @summary Get single account.
     * @param {string} id The ID of the account.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccount(id, xTraceId, date, options) {
        return (0, exports.AccountsApiFp)(this.configuration).getAccount(id, xTraceId, date, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint returns a list of all the accounts owned by the authenticated user.
     * @summary List all accounts.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
     * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    listAccount(xTraceId, limit, page, date, type, options) {
        return (0, exports.AccountsApiFp)(this.configuration).listAccount(xTraceId, limit, page, date, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} id The ID of the account.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    listAttachmentByAccount(id, xTraceId, limit, page, options) {
        return (0, exports.AccountsApiFp)(this.configuration).listAttachmentByAccount(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint returns a list of all the piggy banks connected to the account.
     * @summary List all piggy banks related to the account.
     * @param {string} id The ID of the account.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    listPiggyBankByAccount(id, xTraceId, limit, page, options) {
        return (0, exports.AccountsApiFp)(this.configuration).listPiggyBankByAccount(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint returns a list of all the transactions connected to the account.
     * @summary List all transactions related to the account.
     * @param {string} id The ID of the account.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD.
     * @param {string} [end] A date formatted YYYY-MM-DD.
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    listTransactionByAccount(id, xTraceId, limit, page, start, end, type, options) {
        return (0, exports.AccountsApiFp)(this.configuration).listTransactionByAccount(id, xTraceId, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
     * @summary Create new account.
     * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    storeAccount(accountStore, xTraceId, options) {
        return (0, exports.AccountsApiFp)(this.configuration).storeAccount(accountStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory.
     * @summary Update existing account.
     * @param {string} id The ID of the account.
     * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    updateAccount(id, accountUpdate, xTraceId, options) {
        return (0, exports.AccountsApiFp)(this.configuration).updateAccount(id, accountUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountsApi = AccountsApi;
/**
 * AttachmentsApi - axios parameter creator
 * @export
 */
const AttachmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * With this endpoint you delete an attachment, including any stored file data.
         * @summary Delete an attachment.
         * @param {string} id The ID of the single attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteAttachment', 'id', id);
            const localVarPath = `/v1/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type \"application/octet-stream\" and content disposition \"attachment; filename=example.pdf\".
         * @summary Download a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('downloadAttachment', 'id', id);
            const localVarPath = `/v1/attachments/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below).
         * @summary Get a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAttachment', 'id', id);
            const localVarPath = `/v1/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint lists all attachments.
         * @summary List all attachments.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachment: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object.
         * @summary Store a new attachment.
         * @param {AttachmentStore} attachmentStore JSON array or key&#x3D;value pairs with the necessary attachment information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAttachment: (attachmentStore_1, xTraceId_1, ...args_1) => __awaiter(this, [attachmentStore_1, xTraceId_1, ...args_1], void 0, function* (attachmentStore, xTraceId, options = {}) {
            // verify required parameter 'attachmentStore' is not null or undefined
            (0, common_1.assertParamExists)('storeAttachment', 'attachmentStore', attachmentStore);
            const localVarPath = `/v1/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(attachmentStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below.
         * @summary Update existing attachment.
         * @param {string} id The ID of the attachment.
         * @param {AttachmentUpdate} attachmentUpdate JSON array with updated attachment information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment: (id_1, attachmentUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, attachmentUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, attachmentUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateAttachment', 'id', id);
            // verify required parameter 'attachmentUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateAttachment', 'attachmentUpdate', attachmentUpdate);
            const localVarPath = `/v1/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(attachmentUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data.
         * @summary Upload an attachment.
         * @param {string} id The ID of the attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {File} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: (id_1, xTraceId_1, body_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, body_1, ...args_1], void 0, function* (id, xTraceId, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('uploadAttachment', 'id', id);
            const localVarPath = `/v1/attachments/{id}/upload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AttachmentsApiAxiosParamCreator = AttachmentsApiAxiosParamCreator;
/**
 * AttachmentsApi - functional programming interface
 * @export
 */
const AttachmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AttachmentsApiAxiosParamCreator)(configuration);
    return {
        /**
         * With this endpoint you delete an attachment, including any stored file data.
         * @summary Delete an attachment.
         * @param {string} id The ID of the single attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAttachment(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AttachmentsApi.deleteAttachment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type \"application/octet-stream\" and content disposition \"attachment; filename=example.pdf\".
         * @summary Download a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadAttachment(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AttachmentsApi.downloadAttachment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below).
         * @summary Get a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAttachment(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AttachmentsApi.getAttachment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint lists all attachments.
         * @summary List all attachments.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachment(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAttachment(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AttachmentsApi.listAttachment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object.
         * @summary Store a new attachment.
         * @param {AttachmentStore} attachmentStore JSON array or key&#x3D;value pairs with the necessary attachment information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAttachment(attachmentStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeAttachment(attachmentStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AttachmentsApi.storeAttachment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below.
         * @summary Update existing attachment.
         * @param {string} id The ID of the attachment.
         * @param {AttachmentUpdate} attachmentUpdate JSON array with updated attachment information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment(id, attachmentUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAttachment(id, attachmentUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AttachmentsApi.updateAttachment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data.
         * @summary Upload an attachment.
         * @param {string} id The ID of the attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {File} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(id, xTraceId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadAttachment(id, xTraceId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AttachmentsApi.uploadAttachment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AttachmentsApiFp = AttachmentsApiFp;
/**
 * AttachmentsApi - factory interface
 * @export
 */
const AttachmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AttachmentsApiFp)(configuration);
    return {
        /**
         * With this endpoint you delete an attachment, including any stored file data.
         * @summary Delete an attachment.
         * @param {string} id The ID of the single attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id, xTraceId, options) {
            return localVarFp.deleteAttachment(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type \"application/octet-stream\" and content disposition \"attachment; filename=example.pdf\".
         * @summary Download a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(id, xTraceId, options) {
            return localVarFp.downloadAttachment(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below).
         * @summary Get a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id, xTraceId, options) {
            return localVarFp.getAttachment(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists all attachments.
         * @summary List all attachments.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachment(xTraceId, limit, page, options) {
            return localVarFp.listAttachment(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object.
         * @summary Store a new attachment.
         * @param {AttachmentStore} attachmentStore JSON array or key&#x3D;value pairs with the necessary attachment information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAttachment(attachmentStore, xTraceId, options) {
            return localVarFp.storeAttachment(attachmentStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below.
         * @summary Update existing attachment.
         * @param {string} id The ID of the attachment.
         * @param {AttachmentUpdate} attachmentUpdate JSON array with updated attachment information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment(id, attachmentUpdate, xTraceId, options) {
            return localVarFp.updateAttachment(id, attachmentUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data.
         * @summary Upload an attachment.
         * @param {string} id The ID of the attachment.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {File} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(id, xTraceId, body, options) {
            return localVarFp.uploadAttachment(id, xTraceId, body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AttachmentsApiFactory = AttachmentsApiFactory;
/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
class AttachmentsApi extends base_1.BaseAPI {
    /**
     * With this endpoint you delete an attachment, including any stored file data.
     * @summary Delete an attachment.
     * @param {string} id The ID of the single attachment.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    deleteAttachment(id, xTraceId, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).deleteAttachment(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type \"application/octet-stream\" and content disposition \"attachment; filename=example.pdf\".
     * @summary Download a single attachment.
     * @param {string} id The ID of the attachment.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    downloadAttachment(id, xTraceId, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).downloadAttachment(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below).
     * @summary Get a single attachment.
     * @param {string} id The ID of the attachment.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    getAttachment(id, xTraceId, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).getAttachment(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint lists all attachments.
     * @summary List all attachments.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    listAttachment(xTraceId, limit, page, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).listAttachment(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object.
     * @summary Store a new attachment.
     * @param {AttachmentStore} attachmentStore JSON array or key&#x3D;value pairs with the necessary attachment information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    storeAttachment(attachmentStore, xTraceId, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).storeAttachment(attachmentStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below.
     * @summary Update existing attachment.
     * @param {string} id The ID of the attachment.
     * @param {AttachmentUpdate} attachmentUpdate JSON array with updated attachment information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    updateAttachment(id, attachmentUpdate, xTraceId, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).updateAttachment(id, attachmentUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data.
     * @summary Upload an attachment.
     * @param {string} id The ID of the attachment.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    uploadAttachment(id, xTraceId, body, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).uploadAttachment(id, xTraceId, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AttachmentsApi = AttachmentsApi;
/**
 * AutocompleteApi - axios parameter creator
 * @export
 */
const AutocompleteApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns all accounts of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {string} [date] If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
         * @param {Array<AccountTypeFilter>} [types] Optional filter on the account type(s) used in the autocomplete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAC: (xTraceId_1, query_1, limit_1, date_1, types_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, date_1, types_1, ...args_1], void 0, function* (xTraceId, query, limit, date, types, options = {}) {
            const localVarPath = `/v1/autocomplete/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }
            if (types) {
                localVarQueryParameter['types'] = types.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all bills of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillsAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/bills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all budgets of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetsAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all categories of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all currencies of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all currencies of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesCodeAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/currencies-with-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all object groups of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroupsAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/object-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/piggy-banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesBalanceAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/piggy-banks-with-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all recurring transactions of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all rule groups of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroupsAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/rule-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all rules of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all tags of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all transaction types returned in a basic auto-complete array. English only.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTypesAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/transaction-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all transaction descriptions of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all transactions, complemented with their ID, of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsIDAC: (xTraceId_1, query_1, limit_1, ...args_1) => __awaiter(this, [xTraceId_1, query_1, limit_1, ...args_1], void 0, function* (xTraceId, query, limit, options = {}) {
            const localVarPath = `/v1/autocomplete/transactions-with-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AutocompleteApiAxiosParamCreator = AutocompleteApiAxiosParamCreator;
/**
 * AutocompleteApi - functional programming interface
 * @export
 */
const AutocompleteApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AutocompleteApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Returns all accounts of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {string} [date] If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
         * @param {Array<AccountTypeFilter>} [types] Optional filter on the account type(s) used in the autocomplete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAC(xTraceId, query, limit, date, types, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountsAC(xTraceId, query, limit, date, types, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getAccountsAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all bills of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillsAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBillsAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getBillsAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all budgets of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetsAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBudgetsAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getBudgetsAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all categories of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCategoriesAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getCategoriesAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all currencies of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCurrenciesAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getCurrenciesAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all currencies of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesCodeAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCurrenciesCodeAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getCurrenciesCodeAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all object groups of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroupsAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getObjectGroupsAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getObjectGroupsAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPiggiesAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getPiggiesAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesBalanceAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPiggiesBalanceAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getPiggiesBalanceAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all recurring transactions of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRecurringAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getRecurringAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all rule groups of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroupsAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRuleGroupsAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getRuleGroupsAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all rules of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRulesAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getRulesAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all tags of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTagAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getTagAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all transaction types returned in a basic auto-complete array. English only.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTypesAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionTypesAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getTransactionTypesAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all transaction descriptions of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionsAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getTransactionsAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all transactions, complemented with their ID, of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsIDAC(xTraceId, query, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionsIDAC(xTraceId, query, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AutocompleteApi.getTransactionsIDAC']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AutocompleteApiFp = AutocompleteApiFp;
/**
 * AutocompleteApi - factory interface
 * @export
 */
const AutocompleteApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AutocompleteApiFp)(configuration);
    return {
        /**
         *
         * @summary Returns all accounts of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {string} [date] If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
         * @param {Array<AccountTypeFilter>} [types] Optional filter on the account type(s) used in the autocomplete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAC(xTraceId, query, limit, date, types, options) {
            return localVarFp.getAccountsAC(xTraceId, query, limit, date, types, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all bills of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillsAC(xTraceId, query, limit, options) {
            return localVarFp.getBillsAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all budgets of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetsAC(xTraceId, query, limit, options) {
            return localVarFp.getBudgetsAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all categories of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesAC(xTraceId, query, limit, options) {
            return localVarFp.getCategoriesAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all currencies of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesAC(xTraceId, query, limit, options) {
            return localVarFp.getCurrenciesAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all currencies of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesCodeAC(xTraceId, query, limit, options) {
            return localVarFp.getCurrenciesCodeAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all object groups of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroupsAC(xTraceId, query, limit, options) {
            return localVarFp.getObjectGroupsAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesAC(xTraceId, query, limit, options) {
            return localVarFp.getPiggiesAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesBalanceAC(xTraceId, query, limit, options) {
            return localVarFp.getPiggiesBalanceAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all recurring transactions of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringAC(xTraceId, query, limit, options) {
            return localVarFp.getRecurringAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all rule groups of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroupsAC(xTraceId, query, limit, options) {
            return localVarFp.getRuleGroupsAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all rules of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesAC(xTraceId, query, limit, options) {
            return localVarFp.getRulesAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all tags of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAC(xTraceId, query, limit, options) {
            return localVarFp.getTagAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all transaction types returned in a basic auto-complete array. English only.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTypesAC(xTraceId, query, limit, options) {
            return localVarFp.getTransactionTypesAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all transaction descriptions of the user returned in a basic auto-complete array.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsAC(xTraceId, query, limit, options) {
            return localVarFp.getTransactionsAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all transactions, complemented with their ID, of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsIDAC(xTraceId, query, limit, options) {
            return localVarFp.getTransactionsIDAC(xTraceId, query, limit, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AutocompleteApiFactory = AutocompleteApiFactory;
/**
 * AutocompleteApi - object-oriented interface
 * @export
 * @class AutocompleteApi
 * @extends {BaseAPI}
 */
class AutocompleteApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns all accounts of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {string} [date] If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
     * @param {Array<AccountTypeFilter>} [types] Optional filter on the account type(s) used in the autocomplete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getAccountsAC(xTraceId, query, limit, date, types, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getAccountsAC(xTraceId, query, limit, date, types, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all bills of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getBillsAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getBillsAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all budgets of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getBudgetsAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getBudgetsAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all categories of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getCategoriesAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getCategoriesAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all currencies of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getCurrenciesAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getCurrenciesAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all currencies of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getCurrenciesCodeAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getCurrenciesCodeAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all object groups of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getObjectGroupsAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getObjectGroupsAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getPiggiesAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getPiggiesAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getPiggiesBalanceAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getPiggiesBalanceAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all recurring transactions of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getRecurringAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getRecurringAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all rule groups of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getRuleGroupsAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getRuleGroupsAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all rules of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getRulesAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getRulesAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all tags of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getTagAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getTagAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all transaction types returned in a basic auto-complete array. English only.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getTransactionTypesAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getTransactionTypesAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all transaction descriptions of the user returned in a basic auto-complete array.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getTransactionsAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getTransactionsAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all transactions, complemented with their ID, of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    getTransactionsIDAC(xTraceId, query, limit, options) {
        return (0, exports.AutocompleteApiFp)(this.configuration).getTransactionsIDAC(xTraceId, query, limit, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AutocompleteApi = AutocompleteApi;
/**
 * AvailableBudgetsApi - axios parameter creator
 * @export
 */
const AvailableBudgetsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a single available budget, by ID.
         * @summary Get a single available budget.
         * @param {string} id The ID of the available budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBudget: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAvailableBudget', 'id', id);
            const localVarPath = `/v1/available-budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Firefly III allows users to set the amount that is available to be budgeted in so-called \"available budgets\". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set.
         * @summary List all available budget amounts.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudget: (xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1], void 0, function* (xTraceId, limit, page, start, end, options = {}) {
            const localVarPath = `/v1/available-budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AvailableBudgetsApiAxiosParamCreator = AvailableBudgetsApiAxiosParamCreator;
/**
 * AvailableBudgetsApi - functional programming interface
 * @export
 */
const AvailableBudgetsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AvailableBudgetsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get a single available budget, by ID.
         * @summary Get a single available budget.
         * @param {string} id The ID of the available budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBudget(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAvailableBudget(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AvailableBudgetsApi.getAvailableBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Firefly III allows users to set the amount that is available to be budgeted in so-called \"available budgets\". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set.
         * @summary List all available budget amounts.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudget(xTraceId, limit, page, start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAvailableBudget(xTraceId, limit, page, start, end, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AvailableBudgetsApi.listAvailableBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AvailableBudgetsApiFp = AvailableBudgetsApiFp;
/**
 * AvailableBudgetsApi - factory interface
 * @export
 */
const AvailableBudgetsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AvailableBudgetsApiFp)(configuration);
    return {
        /**
         * Get a single available budget, by ID.
         * @summary Get a single available budget.
         * @param {string} id The ID of the available budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBudget(id, xTraceId, options) {
            return localVarFp.getAvailableBudget(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Firefly III allows users to set the amount that is available to be budgeted in so-called \"available budgets\". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set.
         * @summary List all available budget amounts.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudget(xTraceId, limit, page, start, end, options) {
            return localVarFp.listAvailableBudget(xTraceId, limit, page, start, end, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AvailableBudgetsApiFactory = AvailableBudgetsApiFactory;
/**
 * AvailableBudgetsApi - object-oriented interface
 * @export
 * @class AvailableBudgetsApi
 * @extends {BaseAPI}
 */
class AvailableBudgetsApi extends base_1.BaseAPI {
    /**
     * Get a single available budget, by ID.
     * @summary Get a single available budget.
     * @param {string} id The ID of the available budget.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableBudgetsApi
     */
    getAvailableBudget(id, xTraceId, options) {
        return (0, exports.AvailableBudgetsApiFp)(this.configuration).getAvailableBudget(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Firefly III allows users to set the amount that is available to be budgeted in so-called \"available budgets\". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set.
     * @summary List all available budget amounts.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD.
     * @param {string} [end] A date formatted YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableBudgetsApi
     */
    listAvailableBudget(xTraceId, limit, page, start, end, options) {
        return (0, exports.AvailableBudgetsApiFp)(this.configuration).listAvailableBudget(xTraceId, limit, page, start, end, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AvailableBudgetsApi = AvailableBudgetsApi;
/**
 * BillsApi - axios parameter creator
 * @export
 */
const BillsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments.
         * @summary Delete a bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBill: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteBill', 'id', id);
            const localVarPath = `/v1/bills/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single bill.
         * @summary Get a single bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBill: (id_1, xTraceId_1, start_1, end_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, start_1, end_1, ...args_1], void 0, function* (id, xTraceId, start, end, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getBill', 'id', id);
            const localVarPath = `/v1/bills/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will list all attachments linked to the bill.
         * @summary List all attachments uploaded to the bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBill: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listAttachmentByBill', 'id', id);
            const localVarPath = `/v1/bills/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will list all the user\'s bills.
         * @summary List all bills.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBill: (xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1], void 0, function* (xTraceId, limit, page, start, end, options = {}) {
            const localVarPath = `/v1/bills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will list all rules that have an action to set the bill to this bill.
         * @summary List all rules associated with the bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByBill: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listRuleByBill', 'id', id);
            const localVarPath = `/v1/bills/{id}/rules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will list all transactions linked to this bill.
         * @summary List all transactions associated with the  bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBill: (id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1], void 0, function* (id, xTraceId, limit, page, start, end, type, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByBill', 'id', id);
            const localVarPath = `/v1/bills/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new bill
         * @param {BillStore} billStore JSON array or key&#x3D;value pairs with the necessary bill information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBill: (billStore_1, xTraceId_1, ...args_1) => __awaiter(this, [billStore_1, xTraceId_1, ...args_1], void 0, function* (billStore, xTraceId, options = {}) {
            // verify required parameter 'billStore' is not null or undefined
            (0, common_1.assertParamExists)('storeBill', 'billStore', billStore);
            const localVarPath = `/v1/bills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(billStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing bill.
         * @summary Update existing bill.
         * @param {string} id The ID of the bill.
         * @param {BillUpdate} billUpdate JSON array or key&#x3D;value pairs with updated bill information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBill: (id_1, billUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, billUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, billUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateBill', 'id', id);
            // verify required parameter 'billUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateBill', 'billUpdate', billUpdate);
            const localVarPath = `/v1/bills/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(billUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BillsApiAxiosParamCreator = BillsApiAxiosParamCreator;
/**
 * BillsApi - functional programming interface
 * @export
 */
const BillsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BillsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments.
         * @summary Delete a bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBill(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBill(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillsApi.deleteBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single bill.
         * @summary Get a single bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBill(id, xTraceId, start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBill(id, xTraceId, start, end, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillsApi.getBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint will list all attachments linked to the bill.
         * @summary List all attachments uploaded to the bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBill(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAttachmentByBill(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillsApi.listAttachmentByBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint will list all the user\'s bills.
         * @summary List all bills.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBill(xTraceId, limit, page, start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBill(xTraceId, limit, page, start, end, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillsApi.listBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint will list all rules that have an action to set the bill to this bill.
         * @summary List all rules associated with the bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByBill(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRuleByBill(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillsApi.listRuleByBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint will list all transactions linked to this bill.
         * @summary List all transactions associated with the  bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBill(id, xTraceId, limit, page, start, end, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionByBill(id, xTraceId, limit, page, start, end, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillsApi.listTransactionByBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new bill
         * @param {BillStore} billStore JSON array or key&#x3D;value pairs with the necessary bill information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBill(billStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeBill(billStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillsApi.storeBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing bill.
         * @summary Update existing bill.
         * @param {string} id The ID of the bill.
         * @param {BillUpdate} billUpdate JSON array or key&#x3D;value pairs with updated bill information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBill(id, billUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBill(id, billUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillsApi.updateBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.BillsApiFp = BillsApiFp;
/**
 * BillsApi - factory interface
 * @export
 */
const BillsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BillsApiFp)(configuration);
    return {
        /**
         * Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments.
         * @summary Delete a bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBill(id, xTraceId, options) {
            return localVarFp.deleteBill(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single bill.
         * @summary Get a single bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBill(id, xTraceId, start, end, options) {
            return localVarFp.getBill(id, xTraceId, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will list all attachments linked to the bill.
         * @summary List all attachments uploaded to the bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBill(id, xTraceId, limit, page, options) {
            return localVarFp.listAttachmentByBill(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will list all the user\'s bills.
         * @summary List all bills.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBill(xTraceId, limit, page, start, end, options) {
            return localVarFp.listBill(xTraceId, limit, page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will list all rules that have an action to set the bill to this bill.
         * @summary List all rules associated with the bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByBill(id, xTraceId, options) {
            return localVarFp.listRuleByBill(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will list all transactions linked to this bill.
         * @summary List all transactions associated with the  bill.
         * @param {string} id The ID of the bill.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBill(id, xTraceId, limit, page, start, end, type, options) {
            return localVarFp.listTransactionByBill(id, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new bill
         * @param {BillStore} billStore JSON array or key&#x3D;value pairs with the necessary bill information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBill(billStore, xTraceId, options) {
            return localVarFp.storeBill(billStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing bill.
         * @summary Update existing bill.
         * @param {string} id The ID of the bill.
         * @param {BillUpdate} billUpdate JSON array or key&#x3D;value pairs with updated bill information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBill(id, billUpdate, xTraceId, options) {
            return localVarFp.updateBill(id, billUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BillsApiFactory = BillsApiFactory;
/**
 * BillsApi - object-oriented interface
 * @export
 * @class BillsApi
 * @extends {BaseAPI}
 */
class BillsApi extends base_1.BaseAPI {
    /**
     * Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments.
     * @summary Delete a bill.
     * @param {string} id The ID of the bill.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    deleteBill(id, xTraceId, options) {
        return (0, exports.BillsApiFp)(this.configuration).deleteBill(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single bill.
     * @summary Get a single bill.
     * @param {string} id The ID of the bill.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
     * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    getBill(id, xTraceId, start, end, options) {
        return (0, exports.BillsApiFp)(this.configuration).getBill(id, xTraceId, start, end, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will list all attachments linked to the bill.
     * @summary List all attachments uploaded to the bill.
     * @param {string} id The ID of the bill.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    listAttachmentByBill(id, xTraceId, limit, page, options) {
        return (0, exports.BillsApiFp)(this.configuration).listAttachmentByBill(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will list all the user\'s bills.
     * @summary List all bills.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
     * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    listBill(xTraceId, limit, page, start, end, options) {
        return (0, exports.BillsApiFp)(this.configuration).listBill(xTraceId, limit, page, start, end, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will list all rules that have an action to set the bill to this bill.
     * @summary List all rules associated with the bill.
     * @param {string} id The ID of the bill.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    listRuleByBill(id, xTraceId, options) {
        return (0, exports.BillsApiFp)(this.configuration).listRuleByBill(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will list all transactions linked to this bill.
     * @summary List all transactions associated with the  bill.
     * @param {string} id The ID of the bill.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD.
     * @param {string} [end] A date formatted YYYY-MM-DD.
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    listTransactionByBill(id, xTraceId, limit, page, start, end, type, options) {
        return (0, exports.BillsApiFp)(this.configuration).listTransactionByBill(id, xTraceId, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new bill
     * @param {BillStore} billStore JSON array or key&#x3D;value pairs with the necessary bill information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    storeBill(billStore, xTraceId, options) {
        return (0, exports.BillsApiFp)(this.configuration).storeBill(billStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing bill.
     * @summary Update existing bill.
     * @param {string} id The ID of the bill.
     * @param {BillUpdate} billUpdate JSON array or key&#x3D;value pairs with updated bill information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    updateBill(id, billUpdate, xTraceId, options) {
        return (0, exports.BillsApiFp)(this.configuration).updateBill(id, billUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BillsApi = BillsApi;
/**
 * BudgetsApi - axios parameter creator
 * @export
 */
const BudgetsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteBudget', 'id', id);
            const localVarPath = `/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetLimit: (id_1, limitId_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, limitId_1, xTraceId_1, ...args_1], void 0, function* (id, limitId, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteBudgetLimit', 'id', id);
            // verify required parameter 'limitId' is not null or undefined
            (0, common_1.assertParamExists)('deleteBudgetLimit', 'limitId', limitId);
            const localVarPath = `/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent.
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudget: (id_1, xTraceId_1, start_1, end_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, start_1, end_1, ...args_1], void 0, function* (id, xTraceId, start, end, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getBudget', 'id', id);
            const localVarPath = `/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetLimit: (id_1, limitId_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, limitId_1, xTraceId_1, ...args_1], void 0, function* (id, limitId, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getBudgetLimit', 'id', id);
            // verify required parameter 'limitId' is not null or undefined
            (0, common_1.assertParamExists)('getBudgetLimit', 'limitId', limitId);
            const localVarPath = `/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBudget: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listAttachmentByBudget', 'id', id);
            const localVarPath = `/v1/budgets/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudget: (xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1], void 0, function* (xTraceId, limit, page, start, end, options = {}) {
            const localVarPath = `/v1/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all budget limits for for this date range.
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimit: (start_1, end_1, xTraceId_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, ...args_1], void 0, function* (start, end, xTraceId, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('listBudgetLimit', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('listBudgetLimit', 'end', end);
            const localVarPath = `/v1/budget-limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself.
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByBudget: (id_1, xTraceId_1, start_1, end_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, start_1, end_1, ...args_1], void 0, function* (id, xTraceId, start, end, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listBudgetLimitByBudget', 'id', id);
            const localVarPath = `/v1/budgets/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudget: (id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1], void 0, function* (id, xTraceId, limit, page, start, end, type, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByBudget', 'id', id);
            const localVarPath = `/v1/budgets/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudgetLimit: (id_1, limitId_1, xTraceId_1, limit_1, page_1, type_1, ...args_1) => __awaiter(this, [id_1, limitId_1, xTraceId_1, limit_1, page_1, type_1, ...args_1], void 0, function* (id, limitId, xTraceId, limit, page, type, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByBudgetLimit', 'id', id);
            // verify required parameter 'limitId' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByBudgetLimit', 'limitId', limitId);
            const localVarPath = `/v1/budgets/{id}/limits/{limitId}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all transactions NOT linked to a budget, possibly limited by start and end
         * @summary All transactions without a budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutBudget: (xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1], void 0, function* (xTraceId, limit, page, start, end, options = {}) {
            const localVarPath = `/v1/budgets/transactions-without-budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudget: (budgetStore_1, xTraceId_1, ...args_1) => __awaiter(this, [budgetStore_1, xTraceId_1, ...args_1], void 0, function* (budgetStore, xTraceId, options = {}) {
            // verify required parameter 'budgetStore' is not null or undefined
            (0, common_1.assertParamExists)('storeBudget', 'budgetStore', budgetStore);
            const localVarPath = `/v1/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(budgetStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudgetLimit: (id_1, budgetLimitStore_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, budgetLimitStore_1, xTraceId_1, ...args_1], void 0, function* (id, budgetLimitStore, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('storeBudgetLimit', 'id', id);
            // verify required parameter 'budgetLimitStore' is not null or undefined
            (0, common_1.assertParamExists)('storeBudgetLimit', 'budgetLimitStore', budgetLimitStore);
            const localVarPath = `/v1/budgets/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(budgetLimitStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget: (id_1, budgetUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, budgetUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, budgetUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateBudget', 'id', id);
            // verify required parameter 'budgetUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateBudget', 'budgetUpdate', budgetUpdate);
            const localVarPath = `/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(budgetUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetLimit: (id_1, limitId_1, budgetLimit_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, limitId_1, budgetLimit_1, xTraceId_1, ...args_1], void 0, function* (id, limitId, budgetLimit, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateBudgetLimit', 'id', id);
            // verify required parameter 'limitId' is not null or undefined
            (0, common_1.assertParamExists)('updateBudgetLimit', 'limitId', limitId);
            // verify required parameter 'budgetLimit' is not null or undefined
            (0, common_1.assertParamExists)('updateBudgetLimit', 'budgetLimit', budgetLimit);
            const localVarPath = `/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(budgetLimit, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BudgetsApiAxiosParamCreator = BudgetsApiAxiosParamCreator;
/**
 * BudgetsApi - functional programming interface
 * @export
 */
const BudgetsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BudgetsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBudget(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.deleteBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetLimit(id, limitId, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBudgetLimit(id, limitId, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.deleteBudgetLimit']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent.
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudget(id, xTraceId, start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBudget(id, xTraceId, start, end, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.getBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetLimit(id, limitId, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBudgetLimit(id, limitId, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.getBudgetLimit']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBudget(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAttachmentByBudget(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.listAttachmentByBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudget(xTraceId, limit, page, start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBudget(xTraceId, limit, page, start, end, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.listBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all budget limits for for this date range.
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimit(start, end, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBudgetLimit(start, end, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.listBudgetLimit']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself.
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByBudget(id, xTraceId, start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBudgetLimitByBudget(id, xTraceId, start, end, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.listBudgetLimitByBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudget(id, xTraceId, limit, page, start, end, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionByBudget(id, xTraceId, limit, page, start, end, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.listTransactionByBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudgetLimit(id, limitId, xTraceId, limit, page, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionByBudgetLimit(id, limitId, xTraceId, limit, page, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.listTransactionByBudgetLimit']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all transactions NOT linked to a budget, possibly limited by start and end
         * @summary All transactions without a budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutBudget(xTraceId, limit, page, start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionWithoutBudget(xTraceId, limit, page, start, end, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.listTransactionWithoutBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudget(budgetStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeBudget(budgetStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.storeBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudgetLimit(id, budgetLimitStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeBudgetLimit(id, budgetLimitStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.storeBudgetLimit']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget(id, budgetUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBudget(id, budgetUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.updateBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetLimit(id, limitId, budgetLimit, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBudgetLimit(id, limitId, budgetLimit, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BudgetsApi.updateBudgetLimit']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.BudgetsApiFp = BudgetsApiFp;
/**
 * BudgetsApi - factory interface
 * @export
 */
const BudgetsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BudgetsApiFp)(configuration);
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget(id, xTraceId, options) {
            return localVarFp.deleteBudget(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetLimit(id, limitId, xTraceId, options) {
            return localVarFp.deleteBudgetLimit(id, limitId, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent.
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudget(id, xTraceId, start, end, options) {
            return localVarFp.getBudget(id, xTraceId, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetLimit(id, limitId, xTraceId, options) {
            return localVarFp.getBudgetLimit(id, limitId, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBudget(id, xTraceId, limit, page, options) {
            return localVarFp.listAttachmentByBudget(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudget(xTraceId, limit, page, start, end, options) {
            return localVarFp.listBudget(xTraceId, limit, page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all budget limits for for this date range.
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimit(start, end, xTraceId, options) {
            return localVarFp.listBudgetLimit(start, end, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself.
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByBudget(id, xTraceId, start, end, options) {
            return localVarFp.listBudgetLimitByBudget(id, xTraceId, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudget(id, xTraceId, limit, page, start, end, type, options) {
            return localVarFp.listTransactionByBudget(id, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudgetLimit(id, limitId, xTraceId, limit, page, type, options) {
            return localVarFp.listTransactionByBudgetLimit(id, limitId, xTraceId, limit, page, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions NOT linked to a budget, possibly limited by start and end
         * @summary All transactions without a budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD.
         * @param {string} [end] A date formatted YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutBudget(xTraceId, limit, page, start, end, options) {
            return localVarFp.listTransactionWithoutBudget(xTraceId, limit, page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudget(budgetStore, xTraceId, options) {
            return localVarFp.storeBudget(budgetStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudgetLimit(id, budgetLimitStore, xTraceId, options) {
            return localVarFp.storeBudgetLimit(id, budgetLimitStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget(id, budgetUpdate, xTraceId, options) {
            return localVarFp.updateBudget(id, budgetUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetLimit(id, limitId, budgetLimit, xTraceId, options) {
            return localVarFp.updateBudgetLimit(id, limitId, budgetLimit, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BudgetsApiFactory = BudgetsApiFactory;
/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
class BudgetsApi extends base_1.BaseAPI {
    /**
     * Delete a budget. Transactions will not be deleted.
     * @summary Delete a budget.
     * @param {string} id The ID of the budget.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    deleteBudget(id, xTraceId, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).deleteBudget(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a budget limit.
     * @summary Delete a budget limit.
     * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    deleteBudgetLimit(id, limitId, xTraceId, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).deleteBudgetLimit(id, limitId, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
     * @summary Get a single budget.
     * @param {string} id The ID of the requested budget.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent.
     * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudget(id, xTraceId, start, end, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).getBudget(id, xTraceId, start, end, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get single budget limit.
     * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudgetLimit(id, limitId, xTraceId, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).getBudgetLimit(id, limitId, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all attachments.
     * @summary Lists all attachments of a budget.
     * @param {string} id The ID of the budget.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    listAttachmentByBudget(id, xTraceId, limit, page, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).listAttachmentByBudget(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
     * @summary List all budgets.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
     * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    listBudget(xTraceId, limit, page, start, end, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).listBudget(xTraceId, limit, page, start, end, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all budget limits for for this date range.
     * @summary Get list of budget limits by date
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    listBudgetLimit(start, end, xTraceId, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).listBudgetLimit(start, end, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself.
     * @summary Get all limits for a budget.
     * @param {string} id The ID of the requested budget.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [start] A date formatted YYYY-MM-DD.
     * @param {string} [end] A date formatted YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    listBudgetLimitByBudget(id, xTraceId, start, end, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).listBudgetLimitByBudget(id, xTraceId, start, end, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all transactions linked to a budget, possibly limited by start and end
     * @summary All transactions to a budget.
     * @param {string} id The ID of the budget.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD.
     * @param {string} [end] A date formatted YYYY-MM-DD.
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    listTransactionByBudget(id, xTraceId, limit, page, start, end, type, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).listTransactionByBudget(id, xTraceId, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
     * @summary List all transactions by a budget limit ID.
     * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    listTransactionByBudgetLimit(id, limitId, xTraceId, limit, page, type, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).listTransactionByBudgetLimit(id, limitId, xTraceId, limit, page, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all transactions NOT linked to a budget, possibly limited by start and end
     * @summary All transactions without a budget.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD.
     * @param {string} [end] A date formatted YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    listTransactionWithoutBudget(xTraceId, limit, page, start, end, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).listTransactionWithoutBudget(xTraceId, limit, page, start, end, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new budget
     * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    storeBudget(budgetStore, xTraceId, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).storeBudget(budgetStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Store a new budget limit under this budget.
     * @summary Store new budget limit.
     * @param {string} id The ID of the budget.
     * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    storeBudgetLimit(id, budgetLimitStore, xTraceId, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).storeBudgetLimit(id, budgetLimitStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing budget. This endpoint cannot be used to set budget amount limits.
     * @summary Update existing budget.
     * @param {string} id The ID of the budget.
     * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    updateBudget(id, budgetUpdate, xTraceId, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).updateBudget(id, budgetUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing budget limit.
     * @summary Update existing budget limit.
     * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    updateBudgetLimit(id, limitId, budgetLimit, xTraceId, options) {
        return (0, exports.BudgetsApiFp)(this.configuration).updateBudgetLimit(id, limitId, budgetLimit, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BudgetsApi = BudgetsApi;
/**
 * CategoriesApi - axios parameter creator
 * @export
 */
const CategoriesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteCategory', 'id', id);
            const localVarPath = `/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info.
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: (id_1, xTraceId_1, start_1, end_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, start_1, end_1, ...args_1], void 0, function* (id, xTraceId, start, end, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getCategory', 'id', id);
            const localVarPath = `/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByCategory: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listAttachmentByCategory', 'id', id);
            const localVarPath = `/v1/categories/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all categories.
         * @summary List all categories.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategory: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCategory: (id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1], void 0, function* (id, xTraceId, limit, page, start, end, type, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByCategory', 'id', id);
            const localVarPath = `/v1/categories/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCategory: (category_1, xTraceId_1, ...args_1) => __awaiter(this, [category_1, xTraceId_1, ...args_1], void 0, function* (category, xTraceId, options = {}) {
            // verify required parameter 'category' is not null or undefined
            (0, common_1.assertParamExists)('storeCategory', 'category', category);
            const localVarPath = `/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(category, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: (id_1, categoryUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, categoryUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, categoryUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateCategory', 'id', id);
            // verify required parameter 'categoryUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateCategory', 'categoryUpdate', categoryUpdate);
            const localVarPath = `/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(categoryUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CategoriesApiAxiosParamCreator = CategoriesApiAxiosParamCreator;
/**
 * CategoriesApi - functional programming interface
 * @export
 */
const CategoriesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CategoriesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCategory(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CategoriesApi.deleteCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info.
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(id, xTraceId, start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCategory(id, xTraceId, start, end, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CategoriesApi.getCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByCategory(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAttachmentByCategory(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CategoriesApi.listAttachmentByCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategory(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCategory(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CategoriesApi.listCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCategory(id, xTraceId, limit, page, start, end, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionByCategory(id, xTraceId, limit, page, start, end, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CategoriesApi.listTransactionByCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCategory(category, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeCategory(category, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CategoriesApi.storeCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id, categoryUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCategory(id, categoryUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CategoriesApi.updateCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.CategoriesApiFp = CategoriesApiFp;
/**
 * CategoriesApi - factory interface
 * @export
 */
const CategoriesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CategoriesApiFp)(configuration);
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id, xTraceId, options) {
            return localVarFp.deleteCategory(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info.
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(id, xTraceId, start, end, options) {
            return localVarFp.getCategory(id, xTraceId, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByCategory(id, xTraceId, limit, page, options) {
            return localVarFp.listAttachmentByCategory(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategory(xTraceId, limit, page, options) {
            return localVarFp.listCategory(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCategory(id, xTraceId, limit, page, start, end, type, options) {
            return localVarFp.listTransactionByCategory(id, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCategory(category, xTraceId, options) {
            return localVarFp.storeCategory(category, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id, categoryUpdate, xTraceId, options) {
            return localVarFp.updateCategory(id, categoryUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CategoriesApiFactory = CategoriesApiFactory;
/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
class CategoriesApi extends base_1.BaseAPI {
    /**
     * Delete a category. Transactions will not be removed.
     * @summary Delete a category.
     * @param {string} id The ID of the category.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    deleteCategory(id, xTraceId, options) {
        return (0, exports.CategoriesApiFp)(this.configuration).deleteCategory(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single category.
     * @summary Get a single category.
     * @param {string} id The ID of the category.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info.
     * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategory(id, xTraceId, start, end, options) {
        return (0, exports.CategoriesApiFp)(this.configuration).getCategory(id, xTraceId, start, end, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} id The ID of the category.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    listAttachmentByCategory(id, xTraceId, limit, page, options) {
        return (0, exports.CategoriesApiFp)(this.configuration).listAttachmentByCategory(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all categories.
     * @summary List all categories.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    listCategory(xTraceId, limit, page, options) {
        return (0, exports.CategoriesApiFp)(this.configuration).listCategory(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all transactions in a category, optionally limited to the date ranges specified.
     * @summary List all transactions in a category.
     * @param {string} id The ID of the category.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list.
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list.
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    listTransactionByCategory(id, xTraceId, limit, page, start, end, type, options) {
        return (0, exports.CategoriesApiFp)(this.configuration).listTransactionByCategory(id, xTraceId, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new category
     * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    storeCategory(category, xTraceId, options) {
        return (0, exports.CategoriesApiFp)(this.configuration).storeCategory(category, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing category.
     * @summary Update existing category.
     * @param {string} id The ID of the category.
     * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    updateCategory(id, categoryUpdate, xTraceId, options) {
        return (0, exports.CategoriesApiFp)(this.configuration).updateCategory(id, categoryUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CategoriesApi = CategoriesApi;
/**
 * ChartsApi - axios parameter creator
 * @export
 */
const ChartsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint returns the data required to generate a chart with basic asset account balance information.
         * @summary Dashboard chart with asset account balance information.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartAccountOverview: (start_1, end_1, xTraceId_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, ...args_1], void 0, function* (start, end, xTraceId, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('getChartAccountOverview', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('getChartAccountOverview', 'end', end);
            const localVarPath = `/v1/chart/account/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ChartsApiAxiosParamCreator = ChartsApiAxiosParamCreator;
/**
 * ChartsApi - functional programming interface
 * @export
 */
const ChartsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ChartsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint returns the data required to generate a chart with basic asset account balance information.
         * @summary Dashboard chart with asset account balance information.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartAccountOverview(start, end, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getChartAccountOverview(start, end, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChartsApi.getChartAccountOverview']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ChartsApiFp = ChartsApiFp;
/**
 * ChartsApi - factory interface
 * @export
 */
const ChartsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ChartsApiFp)(configuration);
    return {
        /**
         * This endpoint returns the data required to generate a chart with basic asset account balance information.
         * @summary Dashboard chart with asset account balance information.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartAccountOverview(start, end, xTraceId, options) {
            return localVarFp.getChartAccountOverview(start, end, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ChartsApiFactory = ChartsApiFactory;
/**
 * ChartsApi - object-oriented interface
 * @export
 * @class ChartsApi
 * @extends {BaseAPI}
 */
class ChartsApi extends base_1.BaseAPI {
    /**
     * This endpoint returns the data required to generate a chart with basic asset account balance information.
     * @summary Dashboard chart with asset account balance information.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    getChartAccountOverview(start, end, xTraceId, options) {
        return (0, exports.ChartsApiFp)(this.configuration).getChartAccountOverview(start, end, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ChartsApi = ChartsApi;
/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
const ConfigurationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all editable and not-editable configuration values for this Firefly III installation
         * @summary Get Firefly III system configuration values.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration: (xTraceId_1, ...args_1) => __awaiter(this, [xTraceId_1, ...args_1], void 0, function* (xTraceId, options = {}) {
            const localVarPath = `/v1/configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns one configuration variable for this Firefly III installation
         * @summary Get a single Firefly III system configuration value
         * @param {ConfigValueFilter} name The name of the configuration value you want to know.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleConfiguration: (name_1, xTraceId_1, ...args_1) => __awaiter(this, [name_1, xTraceId_1, ...args_1], void 0, function* (name, xTraceId, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('getSingleConfiguration', 'name', name);
            const localVarPath = `/v1/configuration/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Set a single configuration value. Not all configuration values can be updated so the list of accepted configuration variables is small.
         * @summary Update configuration value
         * @param {ConfigValueUpdateFilter} name The name of the configuration value you want to update.
         * @param {PolymorphicProperty} value
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfiguration: (name_1, value_1, xTraceId_1, ...args_1) => __awaiter(this, [name_1, value_1, xTraceId_1, ...args_1], void 0, function* (name, value, xTraceId, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('setConfiguration', 'name', name);
            // verify required parameter 'value' is not null or undefined
            (0, common_1.assertParamExists)('setConfiguration', 'value', value);
            const localVarPath = `/v1/configuration/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (value !== undefined) {
                localVarFormParams.set('value', value);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ConfigurationApiAxiosParamCreator = ConfigurationApiAxiosParamCreator;
/**
 * ConfigurationApi - functional programming interface
 * @export
 */
const ConfigurationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ConfigurationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns all editable and not-editable configuration values for this Firefly III installation
         * @summary Get Firefly III system configuration values.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration(xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getConfiguration(xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConfigurationApi.getConfiguration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns one configuration variable for this Firefly III installation
         * @summary Get a single Firefly III system configuration value
         * @param {ConfigValueFilter} name The name of the configuration value you want to know.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleConfiguration(name, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleConfiguration(name, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConfigurationApi.getSingleConfiguration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Set a single configuration value. Not all configuration values can be updated so the list of accepted configuration variables is small.
         * @summary Update configuration value
         * @param {ConfigValueUpdateFilter} name The name of the configuration value you want to update.
         * @param {PolymorphicProperty} value
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfiguration(name, value, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.setConfiguration(name, value, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConfigurationApi.setConfiguration']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ConfigurationApiFp = ConfigurationApiFp;
/**
 * ConfigurationApi - factory interface
 * @export
 */
const ConfigurationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ConfigurationApiFp)(configuration);
    return {
        /**
         * Returns all editable and not-editable configuration values for this Firefly III installation
         * @summary Get Firefly III system configuration values.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration(xTraceId, options) {
            return localVarFp.getConfiguration(xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one configuration variable for this Firefly III installation
         * @summary Get a single Firefly III system configuration value
         * @param {ConfigValueFilter} name The name of the configuration value you want to know.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleConfiguration(name, xTraceId, options) {
            return localVarFp.getSingleConfiguration(name, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a single configuration value. Not all configuration values can be updated so the list of accepted configuration variables is small.
         * @summary Update configuration value
         * @param {ConfigValueUpdateFilter} name The name of the configuration value you want to update.
         * @param {PolymorphicProperty} value
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfiguration(name, value, xTraceId, options) {
            return localVarFp.setConfiguration(name, value, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ConfigurationApiFactory = ConfigurationApiFactory;
/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
class ConfigurationApi extends base_1.BaseAPI {
    /**
     * Returns all editable and not-editable configuration values for this Firefly III installation
     * @summary Get Firefly III system configuration values.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    getConfiguration(xTraceId, options) {
        return (0, exports.ConfigurationApiFp)(this.configuration).getConfiguration(xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns one configuration variable for this Firefly III installation
     * @summary Get a single Firefly III system configuration value
     * @param {ConfigValueFilter} name The name of the configuration value you want to know.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    getSingleConfiguration(name, xTraceId, options) {
        return (0, exports.ConfigurationApiFp)(this.configuration).getSingleConfiguration(name, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set a single configuration value. Not all configuration values can be updated so the list of accepted configuration variables is small.
     * @summary Update configuration value
     * @param {ConfigValueUpdateFilter} name The name of the configuration value you want to update.
     * @param {PolymorphicProperty} value
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    setConfiguration(name, value, xTraceId, options) {
        return (0, exports.ConfigurationApiFp)(this.configuration).setConfiguration(name, value, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConfigurationApi = ConfigurationApi;
/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
const CurrenciesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
         * @summary Make currency default currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultCurrency: (code_1, xTraceId_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, ...args_1], void 0, function* (code, xTraceId, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('defaultCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/default`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a currency.
         * @summary Delete a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency: (code_1, xTraceId_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, ...args_1], void 0, function* (code, xTraceId, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('deleteCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Disable a currency.
         * @summary Disable a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableCurrency: (code_1, xTraceId_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, ...args_1], void 0, function* (code, xTraceId, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('disableCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/disable`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Enable a single currency.
         * @summary Enable a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableCurrency: (code_1, xTraceId_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, ...args_1], void 0, function* (code, xTraceId, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('enableCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/enable`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single currency.
         * @summary Get a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency: (code_1, xTraceId_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, ...args_1], void 0, function* (code, xTraceId, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('getCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the native currency of the current administration. This replaces what was called \"the user\'s default currency\" although they are essentially the same.
         * @summary Get the native currency of the current administration.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNativeCurrency: (xTraceId_1, ...args_1) => __awaiter(this, [xTraceId_1, ...args_1], void 0, function* (xTraceId, options = {}) {
            const localVarPath = `/v1/currencies/native`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all accounts with this currency.
         * @summary List all accounts with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountByCurrency: (code_1, xTraceId_1, limit_1, page_1, date_1, type_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, limit_1, page_1, date_1, type_1, ...args_1], void 0, function* (code, xTraceId, limit, page, date, type, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('listAccountByCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/accounts`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (date !== undefined) {
                localVarQueryParameter['date'] = (date instanceof Date) ?
                    date.toISOString().substring(0, 10) :
                    date;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all available budgets with this currency.
         * @summary List all available budgets with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudgetByCurrency: (code_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (code, xTraceId, limit, page, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('listAvailableBudgetByCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/available-budgets`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all bills with this currency.
         * @summary List all bills with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByCurrency: (code_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (code, xTraceId, limit, page, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('listBillByCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/bills`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all budget limits with this currency
         * @summary List all budget limits with this currency
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] Start date for the budget limit list.
         * @param {string} [end] End date for the budget limit list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByCurrency: (code_1, xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, limit_1, page_1, start_1, end_1, ...args_1], void 0, function* (code, xTraceId, limit, page, start, end, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('listBudgetLimitByCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/budget-limits`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all currencies.
         * @summary List all currencies.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all recurring transactions with this currency.
         * @summary List all recurring transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrenceByCurrency: (code_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (code, xTraceId, limit, page, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('listRecurrenceByCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/recurrences`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all rules with this currency.
         * @summary List all rules with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByCurrency: (code_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (code, xTraceId, limit, page, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('listRuleByCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/rules`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all transactions with this currency.
         * @summary List all transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCurrency: (code_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1) => __awaiter(this, [code_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1], void 0, function* (code, xTraceId, limit, page, start, end, type, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByCurrency', 'code', code);
            const localVarPath = `/v1/currencies/{code}/transactions`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency
         * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrency: (currencyStore_1, xTraceId_1, ...args_1) => __awaiter(this, [currencyStore_1, xTraceId_1, ...args_1], void 0, function* (currencyStore, xTraceId, options = {}) {
            // verify required parameter 'currencyStore' is not null or undefined
            (0, common_1.assertParamExists)('storeCurrency', 'currencyStore', currencyStore);
            const localVarPath = `/v1/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(currencyStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing currency.
         * @summary Update existing currency.
         * @param {string} code The currency code.
         * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency: (code_1, currencyUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [code_1, currencyUpdate_1, xTraceId_1, ...args_1], void 0, function* (code, currencyUpdate, xTraceId, options = {}) {
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('updateCurrency', 'code', code);
            // verify required parameter 'currencyUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateCurrency', 'currencyUpdate', currencyUpdate);
            const localVarPath = `/v1/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(currencyUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CurrenciesApiAxiosParamCreator = CurrenciesApiAxiosParamCreator;
/**
 * CurrenciesApi - functional programming interface
 * @export
 */
const CurrenciesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CurrenciesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
         * @summary Make currency default currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultCurrency(code, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.defaultCurrency(code, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.defaultCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a currency.
         * @summary Delete a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency(code, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCurrency(code, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.deleteCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Disable a currency.
         * @summary Disable a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableCurrency(code, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.disableCurrency(code, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.disableCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Enable a single currency.
         * @summary Enable a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableCurrency(code, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.enableCurrency(code, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.enableCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single currency.
         * @summary Get a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(code, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCurrency(code, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.getCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the native currency of the current administration. This replaces what was called \"the user\'s default currency\" although they are essentially the same.
         * @summary Get the native currency of the current administration.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNativeCurrency(xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNativeCurrency(xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.getNativeCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all accounts with this currency.
         * @summary List all accounts with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountByCurrency(code, xTraceId, limit, page, date, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAccountByCurrency(code, xTraceId, limit, page, date, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.listAccountByCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all available budgets with this currency.
         * @summary List all available budgets with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudgetByCurrency(code, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAvailableBudgetByCurrency(code, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.listAvailableBudgetByCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all bills with this currency.
         * @summary List all bills with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByCurrency(code, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBillByCurrency(code, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.listBillByCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all budget limits with this currency
         * @summary List all budget limits with this currency
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] Start date for the budget limit list.
         * @param {string} [end] End date for the budget limit list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByCurrency(code, xTraceId, limit, page, start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBudgetLimitByCurrency(code, xTraceId, limit, page, start, end, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.listBudgetLimitByCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all currencies.
         * @summary List all currencies.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCurrency(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.listCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all recurring transactions with this currency.
         * @summary List all recurring transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrenceByCurrency(code, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRecurrenceByCurrency(code, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.listRecurrenceByCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all rules with this currency.
         * @summary List all rules with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByCurrency(code, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRuleByCurrency(code, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.listRuleByCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all transactions with this currency.
         * @summary List all transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCurrency(code, xTraceId, limit, page, start, end, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionByCurrency(code, xTraceId, limit, page, start, end, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.listTransactionByCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency
         * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrency(currencyStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeCurrency(currencyStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.storeCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing currency.
         * @summary Update existing currency.
         * @param {string} code The currency code.
         * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency(code, currencyUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCurrency(code, currencyUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrenciesApi.updateCurrency']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.CurrenciesApiFp = CurrenciesApiFp;
/**
 * CurrenciesApi - factory interface
 * @export
 */
const CurrenciesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CurrenciesApiFp)(configuration);
    return {
        /**
         * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
         * @summary Make currency default currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultCurrency(code, xTraceId, options) {
            return localVarFp.defaultCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a currency.
         * @summary Delete a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency(code, xTraceId, options) {
            return localVarFp.deleteCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a currency.
         * @summary Disable a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableCurrency(code, xTraceId, options) {
            return localVarFp.disableCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a single currency.
         * @summary Enable a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableCurrency(code, xTraceId, options) {
            return localVarFp.enableCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single currency.
         * @summary Get a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(code, xTraceId, options) {
            return localVarFp.getCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the native currency of the current administration. This replaces what was called \"the user\'s default currency\" although they are essentially the same.
         * @summary Get the native currency of the current administration.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNativeCurrency(xTraceId, options) {
            return localVarFp.getNativeCurrency(xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all accounts with this currency.
         * @summary List all accounts with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountByCurrency(code, xTraceId, limit, page, date, type, options) {
            return localVarFp.listAccountByCurrency(code, xTraceId, limit, page, date, type, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available budgets with this currency.
         * @summary List all available budgets with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudgetByCurrency(code, xTraceId, limit, page, options) {
            return localVarFp.listAvailableBudgetByCurrency(code, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all bills with this currency.
         * @summary List all bills with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByCurrency(code, xTraceId, limit, page, options) {
            return localVarFp.listBillByCurrency(code, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all budget limits with this currency
         * @summary List all budget limits with this currency
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] Start date for the budget limit list.
         * @param {string} [end] End date for the budget limit list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByCurrency(code, xTraceId, limit, page, start, end, options) {
            return localVarFp.listBudgetLimitByCurrency(code, xTraceId, limit, page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * List all currencies.
         * @summary List all currencies.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(xTraceId, limit, page, options) {
            return localVarFp.listCurrency(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all recurring transactions with this currency.
         * @summary List all recurring transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrenceByCurrency(code, xTraceId, limit, page, options) {
            return localVarFp.listRecurrenceByCurrency(code, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rules with this currency.
         * @summary List all rules with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByCurrency(code, xTraceId, limit, page, options) {
            return localVarFp.listRuleByCurrency(code, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions with this currency.
         * @summary List all transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCurrency(code, xTraceId, limit, page, start, end, type, options) {
            return localVarFp.listTransactionByCurrency(code, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency
         * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrency(currencyStore, xTraceId, options) {
            return localVarFp.storeCurrency(currencyStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing currency.
         * @summary Update existing currency.
         * @param {string} code The currency code.
         * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency(code, currencyUpdate, xTraceId, options) {
            return localVarFp.updateCurrency(code, currencyUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CurrenciesApiFactory = CurrenciesApiFactory;
/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
class CurrenciesApi extends base_1.BaseAPI {
    /**
     * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
     * @summary Make currency default currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    defaultCurrency(code, xTraceId, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).defaultCurrency(code, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a currency.
     * @summary Delete a currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    deleteCurrency(code, xTraceId, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).deleteCurrency(code, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disable a currency.
     * @summary Disable a currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    disableCurrency(code, xTraceId, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).disableCurrency(code, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enable a single currency.
     * @summary Enable a single currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    enableCurrency(code, xTraceId, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).enableCurrency(code, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single currency.
     * @summary Get a single currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    getCurrency(code, xTraceId, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).getCurrency(code, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the native currency of the current administration. This replaces what was called \"the user\'s default currency\" although they are essentially the same.
     * @summary Get the native currency of the current administration.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    getNativeCurrency(xTraceId, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).getNativeCurrency(xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all accounts with this currency.
     * @summary List all accounts with this currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day.
     * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    listAccountByCurrency(code, xTraceId, limit, page, date, type, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).listAccountByCurrency(code, xTraceId, limit, page, date, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all available budgets with this currency.
     * @summary List all available budgets with this currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    listAvailableBudgetByCurrency(code, xTraceId, limit, page, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).listAvailableBudgetByCurrency(code, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all bills with this currency.
     * @summary List all bills with this currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    listBillByCurrency(code, xTraceId, limit, page, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).listBillByCurrency(code, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all budget limits with this currency
     * @summary List all budget limits with this currency
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] Start date for the budget limit list.
     * @param {string} [end] End date for the budget limit list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    listBudgetLimitByCurrency(code, xTraceId, limit, page, start, end, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).listBudgetLimitByCurrency(code, xTraceId, limit, page, start, end, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all currencies.
     * @summary List all currencies.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    listCurrency(xTraceId, limit, page, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).listCurrency(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all recurring transactions with this currency.
     * @summary List all recurring transactions with this currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    listRecurrenceByCurrency(code, xTraceId, limit, page, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).listRecurrenceByCurrency(code, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all rules with this currency.
     * @summary List all rules with this currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    listRuleByCurrency(code, xTraceId, limit, page, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).listRuleByCurrency(code, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all transactions with this currency.
     * @summary List all transactions with this currency.
     * @param {string} code The currency code.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions.
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions.
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    listTransactionByCurrency(code, xTraceId, limit, page, start, end, type, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).listTransactionByCurrency(code, xTraceId, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new currency
     * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    storeCurrency(currencyStore, xTraceId, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).storeCurrency(currencyStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing currency.
     * @summary Update existing currency.
     * @param {string} code The currency code.
     * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    updateCurrency(code, currencyUpdate, xTraceId, options) {
        return (0, exports.CurrenciesApiFp)(this.configuration).updateCurrency(code, currencyUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CurrenciesApi = CurrenciesApi;
/**
 * CurrencyExchangeRatesApi - axios parameter creator
 * @export
 */
const CurrencyExchangeRatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a specific currency exchange rate.
         * @summary Delete a specific currency exchange rate.
         * @param {string} id The ID of the requested currency exchange rate.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpecificCurrencyExchangeRate: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteSpecificCurrencyExchangeRate', 'id', id);
            const localVarPath = `/v1/exchange-rates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete all currency exchange rates from \'from\' to \'to\' on a specific date or today.
         * @summary Delete all currency exchange rates from \'from\' to \'to\'.
         * @param {string} from The currency code of the \&#39;from\&#39; currency.
         * @param {string} to The currency code of the \&#39;to\&#39; currency.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. Defaults to today.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpecificCurrencyExchangeRates: (from_1, to_1, xTraceId_1, date_1, ...args_1) => __awaiter(this, [from_1, to_1, xTraceId_1, date_1, ...args_1], void 0, function* (from, to, xTraceId, date, options = {}) {
            // verify required parameter 'from' is not null or undefined
            (0, common_1.assertParamExists)('deleteSpecificCurrencyExchangeRates', 'from', from);
            // verify required parameter 'to' is not null or undefined
            (0, common_1.assertParamExists)('deleteSpecificCurrencyExchangeRates', 'to', to);
            const localVarPath = `/v1/exchange-rates/rates/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (date !== undefined) {
                localVarQueryParameter['date'] = (date instanceof Date) ?
                    date.toISOString().substring(0, 10) :
                    date;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List exchange rates.
         * @summary List all exchange rates.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrencyExchangeRates: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/exchange-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List a single specific exchange rate
         * @summary List a single specific exchange rate.
         * @param {string} id The ID of the requested currency exchange rate.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpecificCurrencyExchangeRate: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listSpecificCurrencyExchangeRate', 'id', id);
            const localVarPath = `/v1/exchange-rates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all exchange rate from/to the mentioned currencies.
         * @summary List all exchange rate from/to the mentioned currencies.
         * @param {string} from The currency code of the \&#39;from\&#39; currency.
         * @param {string} to The currency code of the \&#39;to\&#39; currency.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpecificCurrencyExchangeRates: (from_1, to_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [from_1, to_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (from, to, xTraceId, limit, page, options = {}) {
            // verify required parameter 'from' is not null or undefined
            (0, common_1.assertParamExists)('listSpecificCurrencyExchangeRates', 'from', from);
            // verify required parameter 'to' is not null or undefined
            (0, common_1.assertParamExists)('listSpecificCurrencyExchangeRates', 'to', to);
            const localVarPath = `/v1/exchange-rates/rates/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Stores a new exchange rate. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency exchange rate.
         * @param {CurrencyExchangeRateStore} currencyExchangeRateStore JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrencyExchangeRate: (currencyExchangeRateStore_1, xTraceId_1, ...args_1) => __awaiter(this, [currencyExchangeRateStore_1, xTraceId_1, ...args_1], void 0, function* (currencyExchangeRateStore, xTraceId, options = {}) {
            // verify required parameter 'currencyExchangeRateStore' is not null or undefined
            (0, common_1.assertParamExists)('storeCurrencyExchangeRate', 'currencyExchangeRateStore', currencyExchangeRateStore);
            const localVarPath = `/v1/exchange-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(currencyExchangeRateStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CurrencyExchangeRatesApiAxiosParamCreator = CurrencyExchangeRatesApiAxiosParamCreator;
/**
 * CurrencyExchangeRatesApi - functional programming interface
 * @export
 */
const CurrencyExchangeRatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CurrencyExchangeRatesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a specific currency exchange rate.
         * @summary Delete a specific currency exchange rate.
         * @param {string} id The ID of the requested currency exchange rate.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpecificCurrencyExchangeRate(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSpecificCurrencyExchangeRate(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrencyExchangeRatesApi.deleteSpecificCurrencyExchangeRate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete all currency exchange rates from \'from\' to \'to\' on a specific date or today.
         * @summary Delete all currency exchange rates from \'from\' to \'to\'.
         * @param {string} from The currency code of the \&#39;from\&#39; currency.
         * @param {string} to The currency code of the \&#39;to\&#39; currency.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. Defaults to today.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpecificCurrencyExchangeRates(from, to, xTraceId, date, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSpecificCurrencyExchangeRates(from, to, xTraceId, date, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrencyExchangeRatesApi.deleteSpecificCurrencyExchangeRates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List exchange rates.
         * @summary List all exchange rates.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrencyExchangeRates(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCurrencyExchangeRates(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrencyExchangeRatesApi.listCurrencyExchangeRates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List a single specific exchange rate
         * @summary List a single specific exchange rate.
         * @param {string} id The ID of the requested currency exchange rate.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpecificCurrencyExchangeRate(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listSpecificCurrencyExchangeRate(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrencyExchangeRatesApi.listSpecificCurrencyExchangeRate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all exchange rate from/to the mentioned currencies.
         * @summary List all exchange rate from/to the mentioned currencies.
         * @param {string} from The currency code of the \&#39;from\&#39; currency.
         * @param {string} to The currency code of the \&#39;to\&#39; currency.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpecificCurrencyExchangeRates(from, to, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listSpecificCurrencyExchangeRates(from, to, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrencyExchangeRatesApi.listSpecificCurrencyExchangeRates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Stores a new exchange rate. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency exchange rate.
         * @param {CurrencyExchangeRateStore} currencyExchangeRateStore JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrencyExchangeRate(currencyExchangeRateStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeCurrencyExchangeRate(currencyExchangeRateStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CurrencyExchangeRatesApi.storeCurrencyExchangeRate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.CurrencyExchangeRatesApiFp = CurrencyExchangeRatesApiFp;
/**
 * CurrencyExchangeRatesApi - factory interface
 * @export
 */
const CurrencyExchangeRatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CurrencyExchangeRatesApiFp)(configuration);
    return {
        /**
         * Delete a specific currency exchange rate.
         * @summary Delete a specific currency exchange rate.
         * @param {string} id The ID of the requested currency exchange rate.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpecificCurrencyExchangeRate(id, xTraceId, options) {
            return localVarFp.deleteSpecificCurrencyExchangeRate(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all currency exchange rates from \'from\' to \'to\' on a specific date or today.
         * @summary Delete all currency exchange rates from \'from\' to \'to\'.
         * @param {string} from The currency code of the \&#39;from\&#39; currency.
         * @param {string} to The currency code of the \&#39;to\&#39; currency.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. Defaults to today.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpecificCurrencyExchangeRates(from, to, xTraceId, date, options) {
            return localVarFp.deleteSpecificCurrencyExchangeRates(from, to, xTraceId, date, options).then((request) => request(axios, basePath));
        },
        /**
         * List exchange rates.
         * @summary List all exchange rates.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrencyExchangeRates(xTraceId, limit, page, options) {
            return localVarFp.listCurrencyExchangeRates(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List a single specific exchange rate
         * @summary List a single specific exchange rate.
         * @param {string} id The ID of the requested currency exchange rate.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpecificCurrencyExchangeRate(id, xTraceId, limit, page, options) {
            return localVarFp.listSpecificCurrencyExchangeRate(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all exchange rate from/to the mentioned currencies.
         * @summary List all exchange rate from/to the mentioned currencies.
         * @param {string} from The currency code of the \&#39;from\&#39; currency.
         * @param {string} to The currency code of the \&#39;to\&#39; currency.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpecificCurrencyExchangeRates(from, to, xTraceId, limit, page, options) {
            return localVarFp.listSpecificCurrencyExchangeRates(from, to, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Stores a new exchange rate. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency exchange rate.
         * @param {CurrencyExchangeRateStore} currencyExchangeRateStore JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrencyExchangeRate(currencyExchangeRateStore, xTraceId, options) {
            return localVarFp.storeCurrencyExchangeRate(currencyExchangeRateStore, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CurrencyExchangeRatesApiFactory = CurrencyExchangeRatesApiFactory;
/**
 * CurrencyExchangeRatesApi - object-oriented interface
 * @export
 * @class CurrencyExchangeRatesApi
 * @extends {BaseAPI}
 */
class CurrencyExchangeRatesApi extends base_1.BaseAPI {
    /**
     * Delete a specific currency exchange rate.
     * @summary Delete a specific currency exchange rate.
     * @param {string} id The ID of the requested currency exchange rate.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyExchangeRatesApi
     */
    deleteSpecificCurrencyExchangeRate(id, xTraceId, options) {
        return (0, exports.CurrencyExchangeRatesApiFp)(this.configuration).deleteSpecificCurrencyExchangeRate(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete all currency exchange rates from \'from\' to \'to\' on a specific date or today.
     * @summary Delete all currency exchange rates from \'from\' to \'to\'.
     * @param {string} from The currency code of the \&#39;from\&#39; currency.
     * @param {string} to The currency code of the \&#39;to\&#39; currency.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [date] A date formatted YYYY-MM-DD. Defaults to today.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyExchangeRatesApi
     */
    deleteSpecificCurrencyExchangeRates(from, to, xTraceId, date, options) {
        return (0, exports.CurrencyExchangeRatesApiFp)(this.configuration).deleteSpecificCurrencyExchangeRates(from, to, xTraceId, date, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List exchange rates.
     * @summary List all exchange rates.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyExchangeRatesApi
     */
    listCurrencyExchangeRates(xTraceId, limit, page, options) {
        return (0, exports.CurrencyExchangeRatesApiFp)(this.configuration).listCurrencyExchangeRates(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List a single specific exchange rate
     * @summary List a single specific exchange rate.
     * @param {string} id The ID of the requested currency exchange rate.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyExchangeRatesApi
     */
    listSpecificCurrencyExchangeRate(id, xTraceId, limit, page, options) {
        return (0, exports.CurrencyExchangeRatesApiFp)(this.configuration).listSpecificCurrencyExchangeRate(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all exchange rate from/to the mentioned currencies.
     * @summary List all exchange rate from/to the mentioned currencies.
     * @param {string} from The currency code of the \&#39;from\&#39; currency.
     * @param {string} to The currency code of the \&#39;to\&#39; currency.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyExchangeRatesApi
     */
    listSpecificCurrencyExchangeRates(from, to, xTraceId, limit, page, options) {
        return (0, exports.CurrencyExchangeRatesApiFp)(this.configuration).listSpecificCurrencyExchangeRates(from, to, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Stores a new exchange rate. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new currency exchange rate.
     * @param {CurrencyExchangeRateStore} currencyExchangeRateStore JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyExchangeRatesApi
     */
    storeCurrencyExchangeRate(currencyExchangeRateStore, xTraceId, options) {
        return (0, exports.CurrencyExchangeRatesApiFp)(this.configuration).storeCurrencyExchangeRate(currencyExchangeRateStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CurrencyExchangeRatesApi = CurrencyExchangeRatesApi;
/**
 * DataApi - axios parameter creator
 * @export
 */
const DataApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Allows you to update transactions in bulk.
         * @summary Bulk update transaction properties. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
         * @param {string} query The JSON query.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateTransactions: (query_1, xTraceId_1, ...args_1) => __awaiter(this, [query_1, xTraceId_1, ...args_1], void 0, function* (query, xTraceId, options = {}) {
            // verify required parameter 'query' is not null or undefined
            (0, common_1.assertParamExists)('bulkUpdateTransactions', 'query', query);
            const localVarPath = `/v1/data/bulk/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A call to this endpoint deletes the requested data type. Use it with care and always with user permission. The demo user is incapable of using this endpoint.
         * @summary Endpoint to destroy user data
         * @param {DataDestroyObject} objects The type of data that you wish to destroy. You can only use one at a time.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyData: (objects_1, xTraceId_1, ...args_1) => __awaiter(this, [objects_1, xTraceId_1, ...args_1], void 0, function* (objects, xTraceId, options = {}) {
            // verify required parameter 'objects' is not null or undefined
            (0, common_1.assertParamExists)('destroyData', 'objects', objects);
            const localVarPath = `/v1/data/destroy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (objects !== undefined) {
                localVarQueryParameter['objects'] = objects;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to export your accounts from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export account data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAccounts: (xTraceId_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, type_1, ...args_1], void 0, function* (xTraceId, type, options = {}) {
            const localVarPath = `/v1/data/export/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to export your bills from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export bills from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBills: (xTraceId_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, type_1, ...args_1], void 0, function* (xTraceId, type, options = {}) {
            const localVarPath = `/v1/data/export/bills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to export your budgets and associated budget data from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export budgets and budget amount data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBudgets: (xTraceId_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, type_1, ...args_1], void 0, function* (xTraceId, type, options = {}) {
            const localVarPath = `/v1/data/export/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to export your categories from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export category data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportCategories: (xTraceId_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, type_1, ...args_1], void 0, function* (xTraceId, type, options = {}) {
            const localVarPath = `/v1/data/export/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to export your piggy banks from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export piggy banks from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPiggies: (xTraceId_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, type_1, ...args_1], void 0, function* (xTraceId, type, options = {}) {
            const localVarPath = `/v1/data/export/piggy-banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to export your recurring transactions from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export recurring transaction data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRecurring: (xTraceId_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, type_1, ...args_1], void 0, function* (xTraceId, type, options = {}) {
            const localVarPath = `/v1/data/export/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to export your rules and rule groups from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export rule groups and rule data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRules: (xTraceId_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, type_1, ...args_1], void 0, function* (xTraceId, type, options = {}) {
            const localVarPath = `/v1/data/export/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to export your tags from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export tag data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTags: (xTraceId_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, type_1, ...args_1], void 0, function* (xTraceId, type, options = {}) {
            const localVarPath = `/v1/data/export/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to export transactions from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export transaction data from Firefly III
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [accounts] Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransactions: (start_1, end_1, xTraceId_1, accounts_1, type_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, type_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, type, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('exportTransactions', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('exportTransactions', 'end', end);
            const localVarPath = `/v1/data/export/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts !== undefined) {
                localVarQueryParameter['accounts'] = accounts;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A call to this endpoint purges all previously deleted data. Use it with care and always with user permission. The demo user is incapable of using this endpoint.
         * @summary Endpoint to purge user data
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeData: (xTraceId_1, ...args_1) => __awaiter(this, [xTraceId_1, ...args_1], void 0, function* (xTraceId, options = {}) {
            const localVarPath = `/v1/data/purge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DataApiAxiosParamCreator = DataApiAxiosParamCreator;
/**
 * DataApi - functional programming interface
 * @export
 */
const DataApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DataApiAxiosParamCreator)(configuration);
    return {
        /**
         * Allows you to update transactions in bulk.
         * @summary Bulk update transaction properties. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
         * @param {string} query The JSON query.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateTransactions(query, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.bulkUpdateTransactions(query, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.bulkUpdateTransactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A call to this endpoint deletes the requested data type. Use it with care and always with user permission. The demo user is incapable of using this endpoint.
         * @summary Endpoint to destroy user data
         * @param {DataDestroyObject} objects The type of data that you wish to destroy. You can only use one at a time.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyData(objects, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.destroyData(objects, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.destroyData']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to export your accounts from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export account data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAccounts(xTraceId, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportAccounts(xTraceId, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.exportAccounts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to export your bills from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export bills from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBills(xTraceId, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportBills(xTraceId, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.exportBills']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to export your budgets and associated budget data from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export budgets and budget amount data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBudgets(xTraceId, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportBudgets(xTraceId, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.exportBudgets']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to export your categories from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export category data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportCategories(xTraceId, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportCategories(xTraceId, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.exportCategories']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to export your piggy banks from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export piggy banks from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPiggies(xTraceId, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportPiggies(xTraceId, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.exportPiggies']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to export your recurring transactions from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export recurring transaction data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRecurring(xTraceId, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportRecurring(xTraceId, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.exportRecurring']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to export your rules and rule groups from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export rule groups and rule data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRules(xTraceId, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportRules(xTraceId, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.exportRules']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to export your tags from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export tag data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTags(xTraceId, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportTags(xTraceId, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.exportTags']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint allows you to export transactions from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export transaction data from Firefly III
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [accounts] Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransactions(start, end, xTraceId, accounts, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportTransactions(start, end, xTraceId, accounts, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.exportTransactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A call to this endpoint purges all previously deleted data. Use it with care and always with user permission. The demo user is incapable of using this endpoint.
         * @summary Endpoint to purge user data
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeData(xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.purgeData(xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataApi.purgeData']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.DataApiFp = DataApiFp;
/**
 * DataApi - factory interface
 * @export
 */
const DataApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DataApiFp)(configuration);
    return {
        /**
         * Allows you to update transactions in bulk.
         * @summary Bulk update transaction properties. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
         * @param {string} query The JSON query.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateTransactions(query, xTraceId, options) {
            return localVarFp.bulkUpdateTransactions(query, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * A call to this endpoint deletes the requested data type. Use it with care and always with user permission. The demo user is incapable of using this endpoint.
         * @summary Endpoint to destroy user data
         * @param {DataDestroyObject} objects The type of data that you wish to destroy. You can only use one at a time.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyData(objects, xTraceId, options) {
            return localVarFp.destroyData(objects, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your accounts from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export account data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAccounts(xTraceId, type, options) {
            return localVarFp.exportAccounts(xTraceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your bills from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export bills from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBills(xTraceId, type, options) {
            return localVarFp.exportBills(xTraceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your budgets and associated budget data from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export budgets and budget amount data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBudgets(xTraceId, type, options) {
            return localVarFp.exportBudgets(xTraceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your categories from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export category data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportCategories(xTraceId, type, options) {
            return localVarFp.exportCategories(xTraceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your piggy banks from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export piggy banks from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPiggies(xTraceId, type, options) {
            return localVarFp.exportPiggies(xTraceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your recurring transactions from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export recurring transaction data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRecurring(xTraceId, type, options) {
            return localVarFp.exportRecurring(xTraceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your rules and rule groups from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export rule groups and rule data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRules(xTraceId, type, options) {
            return localVarFp.exportRules(xTraceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your tags from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export tag data from Firefly III
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTags(xTraceId, type, options) {
            return localVarFp.exportTags(xTraceId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export transactions from Firefly III into a file. Currently supports CSV exports only.
         * @summary Export transaction data from Firefly III
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [accounts] Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped.
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransactions(start, end, xTraceId, accounts, type, options) {
            return localVarFp.exportTransactions(start, end, xTraceId, accounts, type, options).then((request) => request(axios, basePath));
        },
        /**
         * A call to this endpoint purges all previously deleted data. Use it with care and always with user permission. The demo user is incapable of using this endpoint.
         * @summary Endpoint to purge user data
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeData(xTraceId, options) {
            return localVarFp.purgeData(xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DataApiFactory = DataApiFactory;
/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
class DataApi extends base_1.BaseAPI {
    /**
     * Allows you to update transactions in bulk.
     * @summary Bulk update transaction properties. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
     * @param {string} query The JSON query.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    bulkUpdateTransactions(query, xTraceId, options) {
        return (0, exports.DataApiFp)(this.configuration).bulkUpdateTransactions(query, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A call to this endpoint deletes the requested data type. Use it with care and always with user permission. The demo user is incapable of using this endpoint.
     * @summary Endpoint to destroy user data
     * @param {DataDestroyObject} objects The type of data that you wish to destroy. You can only use one at a time.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    destroyData(objects, xTraceId, options) {
        return (0, exports.DataApiFp)(this.configuration).destroyData(objects, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to export your accounts from Firefly III into a file. Currently supports CSV exports only.
     * @summary Export account data from Firefly III
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    exportAccounts(xTraceId, type, options) {
        return (0, exports.DataApiFp)(this.configuration).exportAccounts(xTraceId, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to export your bills from Firefly III into a file. Currently supports CSV exports only.
     * @summary Export bills from Firefly III
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    exportBills(xTraceId, type, options) {
        return (0, exports.DataApiFp)(this.configuration).exportBills(xTraceId, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to export your budgets and associated budget data from Firefly III into a file. Currently supports CSV exports only.
     * @summary Export budgets and budget amount data from Firefly III
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    exportBudgets(xTraceId, type, options) {
        return (0, exports.DataApiFp)(this.configuration).exportBudgets(xTraceId, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to export your categories from Firefly III into a file. Currently supports CSV exports only.
     * @summary Export category data from Firefly III
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    exportCategories(xTraceId, type, options) {
        return (0, exports.DataApiFp)(this.configuration).exportCategories(xTraceId, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to export your piggy banks from Firefly III into a file. Currently supports CSV exports only.
     * @summary Export piggy banks from Firefly III
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    exportPiggies(xTraceId, type, options) {
        return (0, exports.DataApiFp)(this.configuration).exportPiggies(xTraceId, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to export your recurring transactions from Firefly III into a file. Currently supports CSV exports only.
     * @summary Export recurring transaction data from Firefly III
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    exportRecurring(xTraceId, type, options) {
        return (0, exports.DataApiFp)(this.configuration).exportRecurring(xTraceId, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to export your rules and rule groups from Firefly III into a file. Currently supports CSV exports only.
     * @summary Export rule groups and rule data from Firefly III
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    exportRules(xTraceId, type, options) {
        return (0, exports.DataApiFp)(this.configuration).exportRules(xTraceId, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to export your tags from Firefly III into a file. Currently supports CSV exports only.
     * @summary Export tag data from Firefly III
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    exportTags(xTraceId, type, options) {
        return (0, exports.DataApiFp)(this.configuration).exportTags(xTraceId, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to export transactions from Firefly III into a file. Currently supports CSV exports only.
     * @summary Export transaction data from Firefly III
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [accounts] Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped.
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    exportTransactions(start, end, xTraceId, accounts, type, options) {
        return (0, exports.DataApiFp)(this.configuration).exportTransactions(start, end, xTraceId, accounts, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A call to this endpoint purges all previously deleted data. Use it with care and always with user permission. The demo user is incapable of using this endpoint.
     * @summary Endpoint to purge user data
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    purgeData(xTraceId, options) {
        return (0, exports.DataApiFp)(this.configuration).purgeData(xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DataApi = DataApi;
/**
 * InsightApi - axios parameter creator
 * @export
 */
const InsightApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by asset account.
         * @summary Insight into expenses, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseAsset: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseAsset', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseAsset', 'end', end);
            const localVarPath = `/v1/insight/expense/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill.
         * @summary Insight into expenses, grouped by bill.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [bills] The bills to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBill: (start_1, end_1, xTraceId_1, bills_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, bills_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, bills, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseBill', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseBill', 'end', end);
            const localVarPath = `/v1/insight/expense/bill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (bills) {
                localVarQueryParameter['bills[]'] = bills;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget.
         * @summary Insight into expenses, grouped by budget.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [budgets] The budgets to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBudget: (start_1, end_1, xTraceId_1, budgets_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, budgets_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, budgets, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseBudget', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseBudget', 'end', end);
            const localVarPath = `/v1/insight/expense/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (budgets) {
                localVarQueryParameter['budgets[]'] = budgets;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) category.
         * @summary Insight into expenses, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [categories] The categories to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseCategory: (start_1, end_1, xTraceId_1, categories_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, categories_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, categories, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseCategory', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseCategory', 'end', end);
            const localVarPath = `/v1/insight/expense/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (categories) {
                localVarQueryParameter['categories[]'] = categories;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by expense account.
         * @summary Insight into expenses, grouped by expense account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of expense accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID\&#39;s. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseExpense: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseExpense', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseExpense', 'end', end);
            const localVarPath = `/v1/insight/expense/expense`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill.
         * @summary Insight into expenses, without bill.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBill: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseNoBill', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseNoBill', 'end', end);
            const localVarPath = `/v1/insight/expense/no-bill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget.
         * @summary Insight into expenses, without budget.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBudget: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseNoBudget', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseNoBudget', 'end', end);
            const localVarPath = `/v1/insight/expense/no-budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no category.
         * @summary Insight into expenses, without category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoCategory: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseNoCategory', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseNoCategory', 'end', end);
            const localVarPath = `/v1/insight/expense/no-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag.
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoTag: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseNoTag', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseNoTag', 'end', end);
            const localVarPath = `/v1/insight/expense/no-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag.
         * @summary Insight into expenses, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [tags] The tags to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTag: (start_1, end_1, xTraceId_1, tags_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, tags_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, tags, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseTag', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseTag', 'end', end);
            const localVarPath = `/v1/insight/expense/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (tags) {
                localVarQueryParameter['tags[]'] = tags;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a sum of the total expenses made by the user.
         * @summary Insight into total expenses.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTotal: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseTotal', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightExpenseTotal', 'end', end);
            const localVarPath = `/v1/insight/expense/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the income received by the user, grouped by asset account.
         * @summary Insight into income, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeAsset: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeAsset', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeAsset', 'end', end);
            const localVarPath = `/v1/insight/income/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) category.
         * @summary Insight into income, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [categories] The categories to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeCategory: (start_1, end_1, xTraceId_1, categories_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, categories_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, categories, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeCategory', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeCategory', 'end', end);
            const localVarPath = `/v1/insight/income/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (categories) {
                localVarQueryParameter['categories[]'] = categories;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no category.
         * @summary Insight into income, without category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoCategory: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeNoCategory', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeNoCategory', 'end', end);
            const localVarPath = `/v1/insight/income/no-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no tag.
         * @summary Insight into income, without tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoTag: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeNoTag', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeNoTag', 'end', end);
            const localVarPath = `/v1/insight/income/no-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the income received by the user, grouped by revenue account.
         * @summary Insight into income, grouped by revenue account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of revenue accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID\&#39;s. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeRevenue: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeRevenue', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeRevenue', 'end', end);
            const localVarPath = `/v1/insight/income/revenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) tag.
         * @summary Insight into income, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [tags] The tags to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTag: (start_1, end_1, xTraceId_1, tags_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, tags_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, tags, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeTag', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeTag', 'end', end);
            const localVarPath = `/v1/insight/income/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (tags) {
                localVarQueryParameter['tags[]'] = tags;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a sum of the total income received by the user.
         * @summary Insight into total income.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTotal: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeTotal', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightIncomeTotal', 'end', end);
            const localVarPath = `/v1/insight/income/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by (any) category.
         * @summary Insight into transfers, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [categories] The categories to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferCategory: (start_1, end_1, xTraceId_1, categories_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, categories_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, categories, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferCategory', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferCategory', 'end', end);
            const localVarPath = `/v1/insight/transfer/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (categories) {
                localVarQueryParameter['categories[]'] = categories;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no category.
         * @summary Insight into transfers, without category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoCategory: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferNoCategory', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferNoCategory', 'end', end);
            const localVarPath = `/v1/insight/transfer/no-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag.
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoTag: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferNoTag', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferNoTag', 'end', end);
            const localVarPath = `/v1/insight/transfer/no-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag.
         * @summary Insight into transfers, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [tags] The tags to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTag: (start_1, end_1, xTraceId_1, tags_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, tags_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, tags, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferTag', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferTag', 'end', end);
            const localVarPath = `/v1/insight/transfer/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (tags) {
                localVarQueryParameter['tags[]'] = tags;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a sum of the total amount transfers made by the user.
         * @summary Insight into total transfers.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTotal: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferTotal', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightTransferTotal', 'end', end);
            const localVarPath = `/v1/insight/transfer/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability.
         * @summary Insight into transfers, grouped by account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransfers: (start_1, end_1, xTraceId_1, accounts_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, accounts_1, ...args_1], void 0, function* (start, end, xTraceId, accounts, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('insightTransfers', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('insightTransfers', 'end', end);
            const localVarPath = `/v1/insight/transfer/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InsightApiAxiosParamCreator = InsightApiAxiosParamCreator;
/**
 * InsightApi - functional programming interface
 * @export
 */
const InsightApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InsightApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by asset account.
         * @summary Insight into expenses, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseAsset(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseAsset(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseAsset']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill.
         * @summary Insight into expenses, grouped by bill.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [bills] The bills to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBill(start, end, xTraceId, bills, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseBill(start, end, xTraceId, bills, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget.
         * @summary Insight into expenses, grouped by budget.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [budgets] The budgets to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBudget(start, end, xTraceId, budgets, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseBudget(start, end, xTraceId, budgets, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) category.
         * @summary Insight into expenses, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [categories] The categories to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseCategory(start, end, xTraceId, categories, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseCategory(start, end, xTraceId, categories, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by expense account.
         * @summary Insight into expenses, grouped by expense account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of expense accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID\&#39;s. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseExpense(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseExpense(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseExpense']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill.
         * @summary Insight into expenses, without bill.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBill(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseNoBill(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseNoBill']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget.
         * @summary Insight into expenses, without budget.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBudget(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseNoBudget(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseNoBudget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no category.
         * @summary Insight into expenses, without category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoCategory(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseNoCategory(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseNoCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag.
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoTag(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseNoTag(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseNoTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag.
         * @summary Insight into expenses, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [tags] The tags to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTag(start, end, xTraceId, tags, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseTag(start, end, xTraceId, tags, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a sum of the total expenses made by the user.
         * @summary Insight into total expenses.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTotal(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightExpenseTotal(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightExpenseTotal']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by asset account.
         * @summary Insight into income, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeAsset(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightIncomeAsset(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightIncomeAsset']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) category.
         * @summary Insight into income, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [categories] The categories to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeCategory(start, end, xTraceId, categories, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightIncomeCategory(start, end, xTraceId, categories, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightIncomeCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no category.
         * @summary Insight into income, without category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoCategory(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightIncomeNoCategory(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightIncomeNoCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no tag.
         * @summary Insight into income, without tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoTag(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightIncomeNoTag(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightIncomeNoTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by revenue account.
         * @summary Insight into income, grouped by revenue account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of revenue accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID\&#39;s. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeRevenue(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightIncomeRevenue(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightIncomeRevenue']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) tag.
         * @summary Insight into income, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [tags] The tags to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTag(start, end, xTraceId, tags, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightIncomeTag(start, end, xTraceId, tags, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightIncomeTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a sum of the total income received by the user.
         * @summary Insight into total income.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTotal(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightIncomeTotal(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightIncomeTotal']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by (any) category.
         * @summary Insight into transfers, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [categories] The categories to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferCategory(start, end, xTraceId, categories, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightTransferCategory(start, end, xTraceId, categories, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightTransferCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no category.
         * @summary Insight into transfers, without category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoCategory(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightTransferNoCategory(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightTransferNoCategory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag.
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoTag(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightTransferNoTag(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightTransferNoTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag.
         * @summary Insight into transfers, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [tags] The tags to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTag(start, end, xTraceId, tags, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightTransferTag(start, end, xTraceId, tags, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightTransferTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a sum of the total amount transfers made by the user.
         * @summary Insight into total transfers.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTotal(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightTransferTotal(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightTransferTotal']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability.
         * @summary Insight into transfers, grouped by account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransfers(start, end, xTraceId, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insightTransfers(start, end, xTraceId, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InsightApi.insightTransfers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.InsightApiFp = InsightApiFp;
/**
 * InsightApi - factory interface
 * @export
 */
const InsightApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InsightApiFp)(configuration);
    return {
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by asset account.
         * @summary Insight into expenses, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseAsset(start, end, xTraceId, accounts, options) {
            return localVarFp.insightExpenseAsset(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill.
         * @summary Insight into expenses, grouped by bill.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [bills] The bills to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBill(start, end, xTraceId, bills, accounts, options) {
            return localVarFp.insightExpenseBill(start, end, xTraceId, bills, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget.
         * @summary Insight into expenses, grouped by budget.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [budgets] The budgets to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBudget(start, end, xTraceId, budgets, accounts, options) {
            return localVarFp.insightExpenseBudget(start, end, xTraceId, budgets, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) category.
         * @summary Insight into expenses, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [categories] The categories to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseCategory(start, end, xTraceId, categories, accounts, options) {
            return localVarFp.insightExpenseCategory(start, end, xTraceId, categories, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by expense account.
         * @summary Insight into expenses, grouped by expense account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of expense accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID\&#39;s. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseExpense(start, end, xTraceId, accounts, options) {
            return localVarFp.insightExpenseExpense(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill.
         * @summary Insight into expenses, without bill.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBill(start, end, xTraceId, accounts, options) {
            return localVarFp.insightExpenseNoBill(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget.
         * @summary Insight into expenses, without budget.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBudget(start, end, xTraceId, accounts, options) {
            return localVarFp.insightExpenseNoBudget(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no category.
         * @summary Insight into expenses, without category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoCategory(start, end, xTraceId, accounts, options) {
            return localVarFp.insightExpenseNoCategory(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag.
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoTag(start, end, xTraceId, accounts, options) {
            return localVarFp.insightExpenseNoTag(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag.
         * @summary Insight into expenses, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [tags] The tags to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTag(start, end, xTraceId, tags, accounts, options) {
            return localVarFp.insightExpenseTag(start, end, xTraceId, tags, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a sum of the total expenses made by the user.
         * @summary Insight into total expenses.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTotal(start, end, xTraceId, accounts, options) {
            return localVarFp.insightExpenseTotal(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by asset account.
         * @summary Insight into income, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeAsset(start, end, xTraceId, accounts, options) {
            return localVarFp.insightIncomeAsset(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) category.
         * @summary Insight into income, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [categories] The categories to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeCategory(start, end, xTraceId, categories, accounts, options) {
            return localVarFp.insightIncomeCategory(start, end, xTraceId, categories, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no category.
         * @summary Insight into income, without category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoCategory(start, end, xTraceId, accounts, options) {
            return localVarFp.insightIncomeNoCategory(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no tag.
         * @summary Insight into income, without tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoTag(start, end, xTraceId, accounts, options) {
            return localVarFp.insightIncomeNoTag(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by revenue account.
         * @summary Insight into income, grouped by revenue account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of revenue accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID\&#39;s. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeRevenue(start, end, xTraceId, accounts, options) {
            return localVarFp.insightIncomeRevenue(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) tag.
         * @summary Insight into income, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [tags] The tags to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTag(start, end, xTraceId, tags, accounts, options) {
            return localVarFp.insightIncomeTag(start, end, xTraceId, tags, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a sum of the total income received by the user.
         * @summary Insight into total income.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTotal(start, end, xTraceId, accounts, options) {
            return localVarFp.insightIncomeTotal(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by (any) category.
         * @summary Insight into transfers, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [categories] The categories to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferCategory(start, end, xTraceId, categories, accounts, options) {
            return localVarFp.insightTransferCategory(start, end, xTraceId, categories, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no category.
         * @summary Insight into transfers, without category.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoCategory(start, end, xTraceId, accounts, options) {
            return localVarFp.insightTransferNoCategory(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag.
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoTag(start, end, xTraceId, accounts, options) {
            return localVarFp.insightTransferNoTag(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag.
         * @summary Insight into transfers, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [tags] The tags to be included in the results.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTag(start, end, xTraceId, tags, accounts, options) {
            return localVarFp.insightTransferTag(start, end, xTraceId, tags, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a sum of the total amount transfers made by the user.
         * @summary Insight into total transfers.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTotal(start, end, xTraceId, accounts, options) {
            return localVarFp.insightTransferTotal(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability.
         * @summary Insight into transfers, grouped by account.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransfers(start, end, xTraceId, accounts, options) {
            return localVarFp.insightTransfers(start, end, xTraceId, accounts, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InsightApiFactory = InsightApiFactory;
/**
 * InsightApi - object-oriented interface
 * @export
 * @class InsightApi
 * @extends {BaseAPI}
 */
class InsightApi extends base_1.BaseAPI {
    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by asset account.
     * @summary Insight into expenses, grouped by asset account.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseAsset(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseAsset(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill.
     * @summary Insight into expenses, grouped by bill.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [bills] The bills to be included in the results.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseBill(start, end, xTraceId, bills, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseBill(start, end, xTraceId, bills, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget.
     * @summary Insight into expenses, grouped by budget.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [budgets] The budgets to be included in the results.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseBudget(start, end, xTraceId, budgets, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseBudget(start, end, xTraceId, budgets, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by (any) category.
     * @summary Insight into expenses, grouped by category.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [categories] The categories to be included in the results.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseCategory(start, end, xTraceId, categories, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseCategory(start, end, xTraceId, categories, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by expense account.
     * @summary Insight into expenses, grouped by expense account.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of expense accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID\&#39;s. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseExpense(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseExpense(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill.
     * @summary Insight into expenses, without bill.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseNoBill(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseNoBill(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget.
     * @summary Insight into expenses, without budget.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseNoBudget(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseNoBudget(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the expenses made by the user, including only expenses with no category.
     * @summary Insight into expenses, without category.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseNoCategory(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseNoCategory(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag.
     * @summary Insight into expenses, without tag.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseNoTag(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseNoTag(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag.
     * @summary Insight into expenses, grouped by tag.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [tags] The tags to be included in the results.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseTag(start, end, xTraceId, tags, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseTag(start, end, xTraceId, tags, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a sum of the total expenses made by the user.
     * @summary Insight into total expenses.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightExpenseTotal(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightExpenseTotal(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the income received by the user, grouped by asset account.
     * @summary Insight into income, grouped by asset account.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightIncomeAsset(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightIncomeAsset(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the income received by the user, grouped by (any) category.
     * @summary Insight into income, grouped by category.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [categories] The categories to be included in the results.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightIncomeCategory(start, end, xTraceId, categories, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightIncomeCategory(start, end, xTraceId, categories, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the income received by the user, including only income with no category.
     * @summary Insight into income, without category.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightIncomeNoCategory(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightIncomeNoCategory(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the income received by the user, including only income with no tag.
     * @summary Insight into income, without tag.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightIncomeNoTag(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightIncomeNoTag(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the income received by the user, grouped by revenue account.
     * @summary Insight into income, grouped by revenue account.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of revenue accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID\&#39;s. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightIncomeRevenue(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightIncomeRevenue(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the income received by the user, grouped by (any) tag.
     * @summary Insight into income, grouped by tag.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [tags] The tags to be included in the results.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightIncomeTag(start, end, xTraceId, tags, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightIncomeTag(start, end, xTraceId, tags, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a sum of the total income received by the user.
     * @summary Insight into total income.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightIncomeTotal(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightIncomeTotal(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the transfers made by the user, grouped by (any) category.
     * @summary Insight into transfers, grouped by category.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [categories] The categories to be included in the results.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightTransferCategory(start, end, xTraceId, categories, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightTransferCategory(start, end, xTraceId, categories, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the transfers made by the user, including only transfers with no category.
     * @summary Insight into transfers, without category.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightTransferNoCategory(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightTransferNoCategory(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag.
     * @summary Insight into expenses, without tag.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightTransferNoTag(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightTransferNoTag(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag.
     * @summary Insight into transfers, grouped by tag.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [tags] The tags to be included in the results.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightTransferTag(start, end, xTraceId, tags, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightTransferTag(start, end, xTraceId, tags, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a sum of the total amount transfers made by the user.
     * @summary Insight into total transfers.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightTransferTotal(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightTransferTotal(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability.
     * @summary Insight into transfers, grouped by account.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    insightTransfers(start, end, xTraceId, accounts, options) {
        return (0, exports.InsightApiFp)(this.configuration).insightTransfers(start, end, xTraceId, accounts, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InsightApi = InsightApi;
/**
 * LinksApi - axios parameter creator
 * @export
 */
const LinksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it.
         * @summary Permanently delete link type.
         * @param {string} id The ID of the link type.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLinkType: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteLinkType', 'id', id);
            const localVarPath = `/v1/link-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Will permanently delete link. Transactions remain.
         * @summary Permanently delete link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionLink: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteTransactionLink', 'id', id);
            const localVarPath = `/v1/transaction-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a single link type by its ID.
         * @summary Get single a link type.
         * @param {string} id The ID of the link type.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkType: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getLinkType', 'id', id);
            const localVarPath = `/v1/link-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a single link by its ID.
         * @summary Get a single link.
         * @param {string} id The ID of the transaction link.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionLink: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionLink', 'id', id);
            const localVarPath = `/v1/transaction-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all the link types the system has. These include the default ones as well as any new ones.
         * @summary List all types of links.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinkType: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/link-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all transactions under this link type, both the inward and outward transactions.
         * @summary List all transactions under this link type.
         * @param {string} id The ID of the link type.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the results.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the results.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByLinkType: (id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1], void 0, function* (id, xTraceId, limit, page, start, end, type, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByLinkType', 'id', id);
            const localVarPath = `/v1/link-types/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all the transaction links.
         * @summary List all transaction links.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionLink: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/transaction-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create a new link type
         * @param {LinkType} linkType JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLinkType: (linkType_1, xTraceId_1, ...args_1) => __awaiter(this, [linkType_1, xTraceId_1, ...args_1], void 0, function* (linkType, xTraceId, options = {}) {
            // verify required parameter 'linkType' is not null or undefined
            (0, common_1.assertParamExists)('storeLinkType', 'linkType', linkType);
            const localVarPath = `/v1/link-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(linkType, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
         * @summary Create a new link between transactions
         * @param {TransactionLinkStore} transactionLinkStore JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransactionLink: (transactionLinkStore_1, xTraceId_1, ...args_1) => __awaiter(this, [transactionLinkStore_1, xTraceId_1, ...args_1], void 0, function* (transactionLinkStore, xTraceId, options = {}) {
            // verify required parameter 'transactionLinkStore' is not null or undefined
            (0, common_1.assertParamExists)('storeTransactionLink', 'transactionLinkStore', transactionLinkStore);
            const localVarPath = `/v1/transaction-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionLinkStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Used to update a single currency exchange rate
         * @summary Update existing currency exchange rate.
         * @param {string} id The ID of the currency exchange rate.
         * @param {CurrencyExchangeRateUpdate} currencyExchangeRateUpdate JSON array or formdata with updated exchange rate information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrencyExchangeRate: (id_1, currencyExchangeRateUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, currencyExchangeRateUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, currencyExchangeRateUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateCurrencyExchangeRate', 'id', id);
            // verify required parameter 'currencyExchangeRateUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateCurrencyExchangeRate', 'currencyExchangeRateUpdate', currencyExchangeRateUpdate);
            const localVarPath = `/v1/exchange-rates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(currencyExchangeRateUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it.
         * @summary Update existing link type.
         * @param {string} id The ID of the link type.
         * @param {LinkTypeUpdate} linkTypeUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkType: (id_1, linkTypeUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, linkTypeUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, linkTypeUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateLinkType', 'id', id);
            // verify required parameter 'linkTypeUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateLinkType', 'linkTypeUpdate', linkTypeUpdate);
            const localVarPath = `/v1/link-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(linkTypeUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Used to update a single existing link.
         * @summary Update an existing link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {TransactionLinkUpdate} transactionLinkUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionLink: (id_1, transactionLinkUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, transactionLinkUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, transactionLinkUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateTransactionLink', 'id', id);
            // verify required parameter 'transactionLinkUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateTransactionLink', 'transactionLinkUpdate', transactionLinkUpdate);
            const localVarPath = `/v1/transaction-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionLinkUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.LinksApiAxiosParamCreator = LinksApiAxiosParamCreator;
/**
 * LinksApi - functional programming interface
 * @export
 */
const LinksApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LinksApiAxiosParamCreator)(configuration);
    return {
        /**
         * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it.
         * @summary Permanently delete link type.
         * @param {string} id The ID of the link type.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLinkType(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteLinkType(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.deleteLinkType']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Will permanently delete link. Transactions remain.
         * @summary Permanently delete link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionLink(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTransactionLink(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.deleteTransactionLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a single link type by its ID.
         * @summary Get single a link type.
         * @param {string} id The ID of the link type.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkType(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLinkType(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.getLinkType']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a single link by its ID.
         * @summary Get a single link.
         * @param {string} id The ID of the transaction link.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionLink(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionLink(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.getTransactionLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all the link types the system has. These include the default ones as well as any new ones.
         * @summary List all types of links.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinkType(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listLinkType(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.listLinkType']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all transactions under this link type, both the inward and outward transactions.
         * @summary List all transactions under this link type.
         * @param {string} id The ID of the link type.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the results.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the results.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByLinkType(id, xTraceId, limit, page, start, end, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionByLinkType(id, xTraceId, limit, page, start, end, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.listTransactionByLinkType']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all the transaction links.
         * @summary List all transaction links.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionLink(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionLink(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.listTransactionLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create a new link type
         * @param {LinkType} linkType JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLinkType(linkType, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeLinkType(linkType, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.storeLinkType']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
         * @summary Create a new link between transactions
         * @param {TransactionLinkStore} transactionLinkStore JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransactionLink(transactionLinkStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeTransactionLink(transactionLinkStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.storeTransactionLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Used to update a single currency exchange rate
         * @summary Update existing currency exchange rate.
         * @param {string} id The ID of the currency exchange rate.
         * @param {CurrencyExchangeRateUpdate} currencyExchangeRateUpdate JSON array or formdata with updated exchange rate information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrencyExchangeRate(id, currencyExchangeRateUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCurrencyExchangeRate(id, currencyExchangeRateUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.updateCurrencyExchangeRate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it.
         * @summary Update existing link type.
         * @param {string} id The ID of the link type.
         * @param {LinkTypeUpdate} linkTypeUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkType(id, linkTypeUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateLinkType(id, linkTypeUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.updateLinkType']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Used to update a single existing link.
         * @summary Update an existing link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {TransactionLinkUpdate} transactionLinkUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionLink(id, transactionLinkUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTransactionLink(id, transactionLinkUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.updateTransactionLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.LinksApiFp = LinksApiFp;
/**
 * LinksApi - factory interface
 * @export
 */
const LinksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LinksApiFp)(configuration);
    return {
        /**
         * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it.
         * @summary Permanently delete link type.
         * @param {string} id The ID of the link type.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLinkType(id, xTraceId, options) {
            return localVarFp.deleteLinkType(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Will permanently delete link. Transactions remain.
         * @summary Permanently delete link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionLink(id, xTraceId, options) {
            return localVarFp.deleteTransactionLink(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single link type by its ID.
         * @summary Get single a link type.
         * @param {string} id The ID of the link type.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkType(id, xTraceId, options) {
            return localVarFp.getLinkType(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single link by its ID.
         * @summary Get a single link.
         * @param {string} id The ID of the transaction link.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionLink(id, xTraceId, options) {
            return localVarFp.getTransactionLink(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the link types the system has. These include the default ones as well as any new ones.
         * @summary List all types of links.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinkType(xTraceId, limit, page, options) {
            return localVarFp.listLinkType(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions under this link type, both the inward and outward transactions.
         * @summary List all transactions under this link type.
         * @param {string} id The ID of the link type.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the results.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the results.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByLinkType(id, xTraceId, limit, page, start, end, type, options) {
            return localVarFp.listTransactionByLinkType(id, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the transaction links.
         * @summary List all transaction links.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionLink(xTraceId, limit, page, options) {
            return localVarFp.listTransactionLink(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create a new link type
         * @param {LinkType} linkType JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLinkType(linkType, xTraceId, options) {
            return localVarFp.storeLinkType(linkType, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
         * @summary Create a new link between transactions
         * @param {TransactionLinkStore} transactionLinkStore JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransactionLink(transactionLinkStore, xTraceId, options) {
            return localVarFp.storeTransactionLink(transactionLinkStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a single currency exchange rate
         * @summary Update existing currency exchange rate.
         * @param {string} id The ID of the currency exchange rate.
         * @param {CurrencyExchangeRateUpdate} currencyExchangeRateUpdate JSON array or formdata with updated exchange rate information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrencyExchangeRate(id, currencyExchangeRateUpdate, xTraceId, options) {
            return localVarFp.updateCurrencyExchangeRate(id, currencyExchangeRateUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it.
         * @summary Update existing link type.
         * @param {string} id The ID of the link type.
         * @param {LinkTypeUpdate} linkTypeUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkType(id, linkTypeUpdate, xTraceId, options) {
            return localVarFp.updateLinkType(id, linkTypeUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a single existing link.
         * @summary Update an existing link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {TransactionLinkUpdate} transactionLinkUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionLink(id, transactionLinkUpdate, xTraceId, options) {
            return localVarFp.updateTransactionLink(id, transactionLinkUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.LinksApiFactory = LinksApiFactory;
/**
 * LinksApi - object-oriented interface
 * @export
 * @class LinksApi
 * @extends {BaseAPI}
 */
class LinksApi extends base_1.BaseAPI {
    /**
     * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it.
     * @summary Permanently delete link type.
     * @param {string} id The ID of the link type.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    deleteLinkType(id, xTraceId, options) {
        return (0, exports.LinksApiFp)(this.configuration).deleteLinkType(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Will permanently delete link. Transactions remain.
     * @summary Permanently delete link between transactions.
     * @param {string} id The ID of the transaction link.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    deleteTransactionLink(id, xTraceId, options) {
        return (0, exports.LinksApiFp)(this.configuration).deleteTransactionLink(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a single link type by its ID.
     * @summary Get single a link type.
     * @param {string} id The ID of the link type.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    getLinkType(id, xTraceId, options) {
        return (0, exports.LinksApiFp)(this.configuration).getLinkType(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a single link by its ID.
     * @summary Get a single link.
     * @param {string} id The ID of the transaction link.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    getTransactionLink(id, xTraceId, options) {
        return (0, exports.LinksApiFp)(this.configuration).getTransactionLink(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all the link types the system has. These include the default ones as well as any new ones.
     * @summary List all types of links.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    listLinkType(xTraceId, limit, page, options) {
        return (0, exports.LinksApiFp)(this.configuration).listLinkType(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all transactions under this link type, both the inward and outward transactions.
     * @summary List all transactions under this link type.
     * @param {string} id The ID of the link type.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the results.
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the results.
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    listTransactionByLinkType(id, xTraceId, limit, page, start, end, type, options) {
        return (0, exports.LinksApiFp)(this.configuration).listTransactionByLinkType(id, xTraceId, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all the transaction links.
     * @summary List all transaction links.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    listTransactionLink(xTraceId, limit, page, options) {
        return (0, exports.LinksApiFp)(this.configuration).listTransactionLink(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
     * @summary Create a new link type
     * @param {LinkType} linkType JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    storeLinkType(linkType, xTraceId, options) {
        return (0, exports.LinksApiFp)(this.configuration).storeLinkType(linkType, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
     * @summary Create a new link between transactions
     * @param {TransactionLinkStore} transactionLinkStore JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    storeTransactionLink(transactionLinkStore, xTraceId, options) {
        return (0, exports.LinksApiFp)(this.configuration).storeTransactionLink(transactionLinkStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Used to update a single currency exchange rate
     * @summary Update existing currency exchange rate.
     * @param {string} id The ID of the currency exchange rate.
     * @param {CurrencyExchangeRateUpdate} currencyExchangeRateUpdate JSON array or formdata with updated exchange rate information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    updateCurrencyExchangeRate(id, currencyExchangeRateUpdate, xTraceId, options) {
        return (0, exports.LinksApiFp)(this.configuration).updateCurrencyExchangeRate(id, currencyExchangeRateUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it.
     * @summary Update existing link type.
     * @param {string} id The ID of the link type.
     * @param {LinkTypeUpdate} linkTypeUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    updateLinkType(id, linkTypeUpdate, xTraceId, options) {
        return (0, exports.LinksApiFp)(this.configuration).updateLinkType(id, linkTypeUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Used to update a single existing link.
     * @summary Update an existing link between transactions.
     * @param {string} id The ID of the transaction link.
     * @param {TransactionLinkUpdate} transactionLinkUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    updateTransactionLink(id, transactionLinkUpdate, xTraceId, options) {
        return (0, exports.LinksApiFp)(this.configuration).updateTransactionLink(id, transactionLinkUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LinksApi = LinksApi;
/**
 * ObjectGroupsApi - axios parameter creator
 * @export
 */
const ObjectGroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a object group.
         * @summary Delete a object group.
         * @param {string} id The ID of the object group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectGroup: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteObjectGroup', 'id', id);
            const localVarPath = `/v1/object-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single object group.
         * @summary Get a single object group.
         * @param {string} id The ID of the object group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroup: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getObjectGroup', 'id', id);
            const localVarPath = `/v1/object-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all bills with this object group.
         * @summary List all bills with this object group.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByObjectGroup: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listBillByObjectGroup', 'id', id);
            const localVarPath = `/v1/object-groups/{id}/bills`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all oject groups.
         * @summary List all oject groups.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjectGroups: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/object-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint returns a list of all the piggy banks connected to the object group.
         * @summary List all piggy banks related to the object group.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByObjectGroup: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listPiggyBankByObjectGroup', 'id', id);
            const localVarPath = `/v1/object-groups/{id}/piggy-banks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing object group.
         * @summary Update existing object group.
         * @param {string} id The ID of the object group
         * @param {ObjectGroupUpdate} objectGroupUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectGroup: (id_1, objectGroupUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, objectGroupUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, objectGroupUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateObjectGroup', 'id', id);
            // verify required parameter 'objectGroupUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateObjectGroup', 'objectGroupUpdate', objectGroupUpdate);
            const localVarPath = `/v1/object-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(objectGroupUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ObjectGroupsApiAxiosParamCreator = ObjectGroupsApiAxiosParamCreator;
/**
 * ObjectGroupsApi - functional programming interface
 * @export
 */
const ObjectGroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ObjectGroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a object group.
         * @summary Delete a object group.
         * @param {string} id The ID of the object group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectGroup(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteObjectGroup(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ObjectGroupsApi.deleteObjectGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single object group.
         * @summary Get a single object group.
         * @param {string} id The ID of the object group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroup(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getObjectGroup(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ObjectGroupsApi.getObjectGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all bills with this object group.
         * @summary List all bills with this object group.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByObjectGroup(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBillByObjectGroup(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ObjectGroupsApi.listBillByObjectGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all oject groups.
         * @summary List all oject groups.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjectGroups(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listObjectGroups(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ObjectGroupsApi.listObjectGroups']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the object group.
         * @summary List all piggy banks related to the object group.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByObjectGroup(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPiggyBankByObjectGroup(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ObjectGroupsApi.listPiggyBankByObjectGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing object group.
         * @summary Update existing object group.
         * @param {string} id The ID of the object group
         * @param {ObjectGroupUpdate} objectGroupUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectGroup(id, objectGroupUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateObjectGroup(id, objectGroupUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ObjectGroupsApi.updateObjectGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ObjectGroupsApiFp = ObjectGroupsApiFp;
/**
 * ObjectGroupsApi - factory interface
 * @export
 */
const ObjectGroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ObjectGroupsApiFp)(configuration);
    return {
        /**
         * Delete a object group.
         * @summary Delete a object group.
         * @param {string} id The ID of the object group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectGroup(id, xTraceId, options) {
            return localVarFp.deleteObjectGroup(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single object group.
         * @summary Get a single object group.
         * @param {string} id The ID of the object group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroup(id, xTraceId, options) {
            return localVarFp.getObjectGroup(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all bills with this object group.
         * @summary List all bills with this object group.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByObjectGroup(id, xTraceId, limit, page, options) {
            return localVarFp.listBillByObjectGroup(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all oject groups.
         * @summary List all oject groups.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjectGroups(xTraceId, limit, page, options) {
            return localVarFp.listObjectGroups(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the object group.
         * @summary List all piggy banks related to the object group.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByObjectGroup(id, xTraceId, limit, page, options) {
            return localVarFp.listPiggyBankByObjectGroup(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing object group.
         * @summary Update existing object group.
         * @param {string} id The ID of the object group
         * @param {ObjectGroupUpdate} objectGroupUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectGroup(id, objectGroupUpdate, xTraceId, options) {
            return localVarFp.updateObjectGroup(id, objectGroupUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ObjectGroupsApiFactory = ObjectGroupsApiFactory;
/**
 * ObjectGroupsApi - object-oriented interface
 * @export
 * @class ObjectGroupsApi
 * @extends {BaseAPI}
 */
class ObjectGroupsApi extends base_1.BaseAPI {
    /**
     * Delete a object group.
     * @summary Delete a object group.
     * @param {string} id The ID of the object group.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    deleteObjectGroup(id, xTraceId, options) {
        return (0, exports.ObjectGroupsApiFp)(this.configuration).deleteObjectGroup(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single object group.
     * @summary Get a single object group.
     * @param {string} id The ID of the object group.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    getObjectGroup(id, xTraceId, options) {
        return (0, exports.ObjectGroupsApiFp)(this.configuration).getObjectGroup(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all bills with this object group.
     * @summary List all bills with this object group.
     * @param {string} id The ID of the account.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    listBillByObjectGroup(id, xTraceId, limit, page, options) {
        return (0, exports.ObjectGroupsApiFp)(this.configuration).listBillByObjectGroup(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all oject groups.
     * @summary List all oject groups.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    listObjectGroups(xTraceId, limit, page, options) {
        return (0, exports.ObjectGroupsApiFp)(this.configuration).listObjectGroups(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint returns a list of all the piggy banks connected to the object group.
     * @summary List all piggy banks related to the object group.
     * @param {string} id The ID of the account.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    listPiggyBankByObjectGroup(id, xTraceId, limit, page, options) {
        return (0, exports.ObjectGroupsApiFp)(this.configuration).listPiggyBankByObjectGroup(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing object group.
     * @summary Update existing object group.
     * @param {string} id The ID of the object group
     * @param {ObjectGroupUpdate} objectGroupUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    updateObjectGroup(id, objectGroupUpdate, xTraceId, options) {
        return (0, exports.ObjectGroupsApiFp)(this.configuration).updateObjectGroup(id, objectGroupUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ObjectGroupsApi = ObjectGroupsApi;
/**
 * PiggyBanksApi - axios parameter creator
 * @export
 */
const PiggyBanksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a piggy bank.
         * @summary Delete a piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePiggyBank: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deletePiggyBank', 'id', id);
            const localVarPath = `/v1/piggy-banks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single piggy bank.
         * @summary Get a single piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggyBank: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getPiggyBank', 'id', id);
            const localVarPath = `/v1/piggy-banks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the piggy bank.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByPiggyBank: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listAttachmentByPiggyBank', 'id', id);
            const localVarPath = `/v1/piggy-banks/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all events linked to a piggy bank (adding and removing money).
         * @summary List all events linked to a piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByPiggyBank: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listEventByPiggyBank', 'id', id);
            const localVarPath = `/v1/piggy-banks/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all piggy banks.
         * @summary List all piggy banks.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBank: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/piggy-banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new piggy bank
         * @param {PiggyBankStore} piggyBankStore JSON array or key&#x3D;value pairs with the necessary piggy bank information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePiggyBank: (piggyBankStore_1, xTraceId_1, ...args_1) => __awaiter(this, [piggyBankStore_1, xTraceId_1, ...args_1], void 0, function* (piggyBankStore, xTraceId, options = {}) {
            // verify required parameter 'piggyBankStore' is not null or undefined
            (0, common_1.assertParamExists)('storePiggyBank', 'piggyBankStore', piggyBankStore);
            const localVarPath = `/v1/piggy-banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(piggyBankStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing piggy bank.
         * @summary Update existing piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {PiggyBankUpdate} piggyBankUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePiggyBank: (id_1, piggyBankUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, piggyBankUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, piggyBankUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updatePiggyBank', 'id', id);
            // verify required parameter 'piggyBankUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updatePiggyBank', 'piggyBankUpdate', piggyBankUpdate);
            const localVarPath = `/v1/piggy-banks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(piggyBankUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PiggyBanksApiAxiosParamCreator = PiggyBanksApiAxiosParamCreator;
/**
 * PiggyBanksApi - functional programming interface
 * @export
 */
const PiggyBanksApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PiggyBanksApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a piggy bank.
         * @summary Delete a piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePiggyBank(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePiggyBank(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PiggyBanksApi.deletePiggyBank']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single piggy bank.
         * @summary Get a single piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggyBank(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPiggyBank(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PiggyBanksApi.getPiggyBank']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the piggy bank.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByPiggyBank(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAttachmentByPiggyBank(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PiggyBanksApi.listAttachmentByPiggyBank']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all events linked to a piggy bank (adding and removing money).
         * @summary List all events linked to a piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByPiggyBank(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listEventByPiggyBank(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PiggyBanksApi.listEventByPiggyBank']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all piggy banks.
         * @summary List all piggy banks.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBank(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPiggyBank(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PiggyBanksApi.listPiggyBank']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new piggy bank
         * @param {PiggyBankStore} piggyBankStore JSON array or key&#x3D;value pairs with the necessary piggy bank information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePiggyBank(piggyBankStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storePiggyBank(piggyBankStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PiggyBanksApi.storePiggyBank']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing piggy bank.
         * @summary Update existing piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {PiggyBankUpdate} piggyBankUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePiggyBank(id, piggyBankUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePiggyBank(id, piggyBankUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PiggyBanksApi.updatePiggyBank']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.PiggyBanksApiFp = PiggyBanksApiFp;
/**
 * PiggyBanksApi - factory interface
 * @export
 */
const PiggyBanksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PiggyBanksApiFp)(configuration);
    return {
        /**
         * Delete a piggy bank.
         * @summary Delete a piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePiggyBank(id, xTraceId, options) {
            return localVarFp.deletePiggyBank(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single piggy bank.
         * @summary Get a single piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggyBank(id, xTraceId, options) {
            return localVarFp.getPiggyBank(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the piggy bank.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByPiggyBank(id, xTraceId, limit, page, options) {
            return localVarFp.listAttachmentByPiggyBank(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all events linked to a piggy bank (adding and removing money).
         * @summary List all events linked to a piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByPiggyBank(id, xTraceId, limit, page, options) {
            return localVarFp.listEventByPiggyBank(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all piggy banks.
         * @summary List all piggy banks.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBank(xTraceId, limit, page, options) {
            return localVarFp.listPiggyBank(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new piggy bank
         * @param {PiggyBankStore} piggyBankStore JSON array or key&#x3D;value pairs with the necessary piggy bank information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePiggyBank(piggyBankStore, xTraceId, options) {
            return localVarFp.storePiggyBank(piggyBankStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing piggy bank.
         * @summary Update existing piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {PiggyBankUpdate} piggyBankUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePiggyBank(id, piggyBankUpdate, xTraceId, options) {
            return localVarFp.updatePiggyBank(id, piggyBankUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PiggyBanksApiFactory = PiggyBanksApiFactory;
/**
 * PiggyBanksApi - object-oriented interface
 * @export
 * @class PiggyBanksApi
 * @extends {BaseAPI}
 */
class PiggyBanksApi extends base_1.BaseAPI {
    /**
     * Delete a piggy bank.
     * @summary Delete a piggy bank.
     * @param {string} id The ID of the piggy bank.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    deletePiggyBank(id, xTraceId, options) {
        return (0, exports.PiggyBanksApiFp)(this.configuration).deletePiggyBank(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single piggy bank.
     * @summary Get a single piggy bank.
     * @param {string} id The ID of the piggy bank.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    getPiggyBank(id, xTraceId, options) {
        return (0, exports.PiggyBanksApiFp)(this.configuration).getPiggyBank(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} id The ID of the piggy bank.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    listAttachmentByPiggyBank(id, xTraceId, limit, page, options) {
        return (0, exports.PiggyBanksApiFp)(this.configuration).listAttachmentByPiggyBank(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all events linked to a piggy bank (adding and removing money).
     * @summary List all events linked to a piggy bank.
     * @param {string} id The ID of the piggy bank
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    listEventByPiggyBank(id, xTraceId, limit, page, options) {
        return (0, exports.PiggyBanksApiFp)(this.configuration).listEventByPiggyBank(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all piggy banks.
     * @summary List all piggy banks.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    listPiggyBank(xTraceId, limit, page, options) {
        return (0, exports.PiggyBanksApiFp)(this.configuration).listPiggyBank(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new piggy bank
     * @param {PiggyBankStore} piggyBankStore JSON array or key&#x3D;value pairs with the necessary piggy bank information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    storePiggyBank(piggyBankStore, xTraceId, options) {
        return (0, exports.PiggyBanksApiFp)(this.configuration).storePiggyBank(piggyBankStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing piggy bank.
     * @summary Update existing piggy bank.
     * @param {string} id The ID of the piggy bank
     * @param {PiggyBankUpdate} piggyBankUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    updatePiggyBank(id, piggyBankUpdate, xTraceId, options) {
        return (0, exports.PiggyBanksApiFp)(this.configuration).updatePiggyBank(id, piggyBankUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PiggyBanksApi = PiggyBanksApi;
/**
 * PreferencesApi - axios parameter creator
 * @export
 */
const PreferencesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Return a single preference and the value.
         * @summary Return a single preference.
         * @param {string} name The name of the preference.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreference: (name_1, xTraceId_1, ...args_1) => __awaiter(this, [name_1, xTraceId_1, ...args_1], void 0, function* (name, xTraceId, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('getPreference', 'name', name);
            const localVarPath = `/v1/preferences/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all of the preferences of the user.
         * @summary List all users preferences.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPreference: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
         * @summary Store a new preference for this user.
         * @param {Preference} preference JSON array with the necessary preference information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePreference: (preference_1, xTraceId_1, ...args_1) => __awaiter(this, [preference_1, xTraceId_1, ...args_1], void 0, function* (preference, xTraceId, options = {}) {
            // verify required parameter 'preference' is not null or undefined
            (0, common_1.assertParamExists)('storePreference', 'preference', preference);
            const localVarPath = `/v1/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(preference, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a user\'s preference.
         * @summary Update preference
         * @param {string} name The name of the preference. Will always overwrite. Will be created if it does not exist.
         * @param {PreferenceUpdate} preferenceUpdate JSON array or key&#x3D;value pairs with the necessary preference information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreference: (name_1, preferenceUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [name_1, preferenceUpdate_1, xTraceId_1, ...args_1], void 0, function* (name, preferenceUpdate, xTraceId, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('updatePreference', 'name', name);
            // verify required parameter 'preferenceUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updatePreference', 'preferenceUpdate', preferenceUpdate);
            const localVarPath = `/v1/preferences/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(preferenceUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PreferencesApiAxiosParamCreator = PreferencesApiAxiosParamCreator;
/**
 * PreferencesApi - functional programming interface
 * @export
 */
const PreferencesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PreferencesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Return a single preference and the value.
         * @summary Return a single preference.
         * @param {string} name The name of the preference.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreference(name, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPreference(name, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PreferencesApi.getPreference']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all of the preferences of the user.
         * @summary List all users preferences.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPreference(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPreference(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PreferencesApi.listPreference']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
         * @summary Store a new preference for this user.
         * @param {Preference} preference JSON array with the necessary preference information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePreference(preference, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storePreference(preference, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PreferencesApi.storePreference']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a user\'s preference.
         * @summary Update preference
         * @param {string} name The name of the preference. Will always overwrite. Will be created if it does not exist.
         * @param {PreferenceUpdate} preferenceUpdate JSON array or key&#x3D;value pairs with the necessary preference information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreference(name, preferenceUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePreference(name, preferenceUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PreferencesApi.updatePreference']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.PreferencesApiFp = PreferencesApiFp;
/**
 * PreferencesApi - factory interface
 * @export
 */
const PreferencesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PreferencesApiFp)(configuration);
    return {
        /**
         * Return a single preference and the value.
         * @summary Return a single preference.
         * @param {string} name The name of the preference.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreference(name, xTraceId, options) {
            return localVarFp.getPreference(name, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the preferences of the user.
         * @summary List all users preferences.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPreference(xTraceId, limit, page, options) {
            return localVarFp.listPreference(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
         * @summary Store a new preference for this user.
         * @param {Preference} preference JSON array with the necessary preference information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePreference(preference, xTraceId, options) {
            return localVarFp.storePreference(preference, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user\'s preference.
         * @summary Update preference
         * @param {string} name The name of the preference. Will always overwrite. Will be created if it does not exist.
         * @param {PreferenceUpdate} preferenceUpdate JSON array or key&#x3D;value pairs with the necessary preference information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreference(name, preferenceUpdate, xTraceId, options) {
            return localVarFp.updatePreference(name, preferenceUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PreferencesApiFactory = PreferencesApiFactory;
/**
 * PreferencesApi - object-oriented interface
 * @export
 * @class PreferencesApi
 * @extends {BaseAPI}
 */
class PreferencesApi extends base_1.BaseAPI {
    /**
     * Return a single preference and the value.
     * @summary Return a single preference.
     * @param {string} name The name of the preference.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    getPreference(name, xTraceId, options) {
        return (0, exports.PreferencesApiFp)(this.configuration).getPreference(name, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all of the preferences of the user.
     * @summary List all users preferences.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    listPreference(xTraceId, limit, page, options) {
        return (0, exports.PreferencesApiFp)(this.configuration).listPreference(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
     * @summary Store a new preference for this user.
     * @param {Preference} preference JSON array with the necessary preference information or key&#x3D;value pairs. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    storePreference(preference, xTraceId, options) {
        return (0, exports.PreferencesApiFp)(this.configuration).storePreference(preference, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a user\'s preference.
     * @summary Update preference
     * @param {string} name The name of the preference. Will always overwrite. Will be created if it does not exist.
     * @param {PreferenceUpdate} preferenceUpdate JSON array or key&#x3D;value pairs with the necessary preference information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    updatePreference(name, preferenceUpdate, xTraceId, options) {
        return (0, exports.PreferencesApiFp)(this.configuration).updatePreference(name, preferenceUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PreferencesApi = PreferencesApi;
/**
 * RecurrencesApi - axios parameter creator
 * @export
 */
const RecurrencesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a recurring transaction. Transactions created by the recurring transaction will not be deleted.
         * @summary Delete a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurrence: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteRecurrence', 'id', id);
            const localVarPath = `/v1/recurrences/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single recurring transaction.
         * @summary Get a single recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurrence: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getRecurrence', 'id', id);
            const localVarPath = `/v1/recurrences/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all recurring transactions.
         * @summary List all recurring transactions.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrence: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/recurrences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all transactions created by a recurring transaction, optionally limited to the date ranges specified.
         * @summary List all transactions created by a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. Both the start and end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD. Both the start and end date must be present.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByRecurrence: (id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1], void 0, function* (id, xTraceId, limit, page, start, end, type, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByRecurrence', 'id', id);
            const localVarPath = `/v1/recurrences/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new recurring transaction
         * @param {RecurrenceStore} recurrenceStore JSON array or key&#x3D;value pairs with the necessary recurring transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRecurrence: (recurrenceStore_1, xTraceId_1, ...args_1) => __awaiter(this, [recurrenceStore_1, xTraceId_1, ...args_1], void 0, function* (recurrenceStore, xTraceId, options = {}) {
            // verify required parameter 'recurrenceStore' is not null or undefined
            (0, common_1.assertParamExists)('storeRecurrence', 'recurrenceStore', recurrenceStore);
            const localVarPath = `/v1/recurrences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(recurrenceStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing recurring transaction.
         * @summary Update existing recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {RecurrenceUpdate} recurrenceUpdate JSON array with updated recurring transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurrence: (id_1, recurrenceUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, recurrenceUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, recurrenceUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateRecurrence', 'id', id);
            // verify required parameter 'recurrenceUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateRecurrence', 'recurrenceUpdate', recurrenceUpdate);
            const localVarPath = `/v1/recurrences/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(recurrenceUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RecurrencesApiAxiosParamCreator = RecurrencesApiAxiosParamCreator;
/**
 * RecurrencesApi - functional programming interface
 * @export
 */
const RecurrencesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RecurrencesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a recurring transaction. Transactions created by the recurring transaction will not be deleted.
         * @summary Delete a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurrence(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRecurrence(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RecurrencesApi.deleteRecurrence']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single recurring transaction.
         * @summary Get a single recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurrence(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRecurrence(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RecurrencesApi.getRecurrence']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all recurring transactions.
         * @summary List all recurring transactions.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrence(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRecurrence(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RecurrencesApi.listRecurrence']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all transactions created by a recurring transaction, optionally limited to the date ranges specified.
         * @summary List all transactions created by a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. Both the start and end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD. Both the start and end date must be present.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByRecurrence(id, xTraceId, limit, page, start, end, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionByRecurrence(id, xTraceId, limit, page, start, end, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RecurrencesApi.listTransactionByRecurrence']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new recurring transaction
         * @param {RecurrenceStore} recurrenceStore JSON array or key&#x3D;value pairs with the necessary recurring transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRecurrence(recurrenceStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeRecurrence(recurrenceStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RecurrencesApi.storeRecurrence']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing recurring transaction.
         * @summary Update existing recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {RecurrenceUpdate} recurrenceUpdate JSON array with updated recurring transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurrence(id, recurrenceUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRecurrence(id, recurrenceUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RecurrencesApi.updateRecurrence']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.RecurrencesApiFp = RecurrencesApiFp;
/**
 * RecurrencesApi - factory interface
 * @export
 */
const RecurrencesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RecurrencesApiFp)(configuration);
    return {
        /**
         * Delete a recurring transaction. Transactions created by the recurring transaction will not be deleted.
         * @summary Delete a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurrence(id, xTraceId, options) {
            return localVarFp.deleteRecurrence(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single recurring transaction.
         * @summary Get a single recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurrence(id, xTraceId, options) {
            return localVarFp.getRecurrence(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all recurring transactions.
         * @summary List all recurring transactions.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrence(xTraceId, limit, page, options) {
            return localVarFp.listRecurrence(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions created by a recurring transaction, optionally limited to the date ranges specified.
         * @summary List all transactions created by a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. Both the start and end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD. Both the start and end date must be present.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByRecurrence(id, xTraceId, limit, page, start, end, type, options) {
            return localVarFp.listTransactionByRecurrence(id, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new recurring transaction
         * @param {RecurrenceStore} recurrenceStore JSON array or key&#x3D;value pairs with the necessary recurring transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRecurrence(recurrenceStore, xTraceId, options) {
            return localVarFp.storeRecurrence(recurrenceStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing recurring transaction.
         * @summary Update existing recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {RecurrenceUpdate} recurrenceUpdate JSON array with updated recurring transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurrence(id, recurrenceUpdate, xTraceId, options) {
            return localVarFp.updateRecurrence(id, recurrenceUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RecurrencesApiFactory = RecurrencesApiFactory;
/**
 * RecurrencesApi - object-oriented interface
 * @export
 * @class RecurrencesApi
 * @extends {BaseAPI}
 */
class RecurrencesApi extends base_1.BaseAPI {
    /**
     * Delete a recurring transaction. Transactions created by the recurring transaction will not be deleted.
     * @summary Delete a recurring transaction.
     * @param {string} id The ID of the recurring transaction.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    deleteRecurrence(id, xTraceId, options) {
        return (0, exports.RecurrencesApiFp)(this.configuration).deleteRecurrence(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single recurring transaction.
     * @summary Get a single recurring transaction.
     * @param {string} id The ID of the recurring transaction.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    getRecurrence(id, xTraceId, options) {
        return (0, exports.RecurrencesApiFp)(this.configuration).getRecurrence(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all recurring transactions.
     * @summary List all recurring transactions.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    listRecurrence(xTraceId, limit, page, options) {
        return (0, exports.RecurrencesApiFp)(this.configuration).listRecurrence(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all transactions created by a recurring transaction, optionally limited to the date ranges specified.
     * @summary List all transactions created by a recurring transaction.
     * @param {string} id The ID of the recurring transaction.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD. Both the start and end date must be present.
     * @param {string} [end] A date formatted YYYY-MM-DD. Both the start and end date must be present.
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    listTransactionByRecurrence(id, xTraceId, limit, page, start, end, type, options) {
        return (0, exports.RecurrencesApiFp)(this.configuration).listTransactionByRecurrence(id, xTraceId, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new recurring transaction
     * @param {RecurrenceStore} recurrenceStore JSON array or key&#x3D;value pairs with the necessary recurring transaction information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    storeRecurrence(recurrenceStore, xTraceId, options) {
        return (0, exports.RecurrencesApiFp)(this.configuration).storeRecurrence(recurrenceStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing recurring transaction.
     * @summary Update existing recurring transaction.
     * @param {string} id The ID of the recurring transaction.
     * @param {RecurrenceUpdate} recurrenceUpdate JSON array with updated recurring transaction information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    updateRecurrence(id, recurrenceUpdate, xTraceId, options) {
        return (0, exports.RecurrencesApiFp)(this.configuration).updateRecurrence(id, recurrenceUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RecurrencesApi = RecurrencesApi;
/**
 * RuleGroupsApi - axios parameter creator
 * @export
 */
const RuleGroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a rule group.
         * @summary Delete a rule group.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleGroup: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteRuleGroup', 'id', id);
            const localVarPath = `/v1/rule-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
         * @summary Fire the rule group on your transactions.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
         * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRuleGroup: (id_1, xTraceId_1, start_1, end_1, accounts_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, start_1, end_1, accounts_1, ...args_1], void 0, function* (id, xTraceId, start, end, accounts, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('fireRuleGroup', 'id', id);
            const localVarPath = `/v1/rule-groups/{id}/trigger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single rule group. This does not include the rules. For that, see below.
         * @summary Get a single rule group.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroup: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getRuleGroup', 'id', id);
            const localVarPath = `/v1/rule-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List rules in this rule group.
         * @summary List rules in this rule group.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByGroup: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listRuleByGroup', 'id', id);
            const localVarPath = `/v1/rule-groups/{id}/rules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all rule groups.
         * @summary List all rule groups.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleGroup: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/rule-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule group.
         * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRuleGroup: (ruleGroupStore_1, xTraceId_1, ...args_1) => __awaiter(this, [ruleGroupStore_1, xTraceId_1, ...args_1], void 0, function* (ruleGroupStore, xTraceId, options = {}) {
            // verify required parameter 'ruleGroupStore' is not null or undefined
            (0, common_1.assertParamExists)('storeRuleGroup', 'ruleGroupStore', ruleGroupStore);
            const localVarPath = `/v1/rule-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(ruleGroupStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule group. No changes will be made.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200.
         * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow.
         * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRuleGroup: (id_1, xTraceId_1, limit_1, page_1, start_1, end_1, searchLimit_1, triggeredLimit_1, accounts_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, start_1, end_1, searchLimit_1, triggeredLimit_1, accounts_1, ...args_1], void 0, function* (id, xTraceId, limit, page, start, end, searchLimit, triggeredLimit, accounts, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('testRuleGroup', 'id', id);
            const localVarPath = `/v1/rule-groups/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (searchLimit !== undefined) {
                localVarQueryParameter['search_limit'] = searchLimit;
            }
            if (triggeredLimit !== undefined) {
                localVarQueryParameter['triggered_limit'] = triggeredLimit;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing rule group.
         * @summary Update existing rule group.
         * @param {string} id The ID of the rule group.
         * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRuleGroup: (id_1, ruleGroupUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, ruleGroupUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, ruleGroupUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateRuleGroup', 'id', id);
            // verify required parameter 'ruleGroupUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateRuleGroup', 'ruleGroupUpdate', ruleGroupUpdate);
            const localVarPath = `/v1/rule-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(ruleGroupUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RuleGroupsApiAxiosParamCreator = RuleGroupsApiAxiosParamCreator;
/**
 * RuleGroupsApi - functional programming interface
 * @export
 */
const RuleGroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RuleGroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a rule group.
         * @summary Delete a rule group.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleGroup(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRuleGroup(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RuleGroupsApi.deleteRuleGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
         * @summary Fire the rule group on your transactions.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
         * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRuleGroup(id, xTraceId, start, end, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fireRuleGroup(id, xTraceId, start, end, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RuleGroupsApi.fireRuleGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single rule group. This does not include the rules. For that, see below.
         * @summary Get a single rule group.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroup(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRuleGroup(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RuleGroupsApi.getRuleGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List rules in this rule group.
         * @summary List rules in this rule group.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByGroup(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRuleByGroup(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RuleGroupsApi.listRuleByGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all rule groups.
         * @summary List all rule groups.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleGroup(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRuleGroup(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RuleGroupsApi.listRuleGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule group.
         * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRuleGroup(ruleGroupStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeRuleGroup(ruleGroupStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RuleGroupsApi.storeRuleGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule group. No changes will be made.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200.
         * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow.
         * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRuleGroup(id, xTraceId, limit, page, start, end, searchLimit, triggeredLimit, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.testRuleGroup(id, xTraceId, limit, page, start, end, searchLimit, triggeredLimit, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RuleGroupsApi.testRuleGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing rule group.
         * @summary Update existing rule group.
         * @param {string} id The ID of the rule group.
         * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRuleGroup(id, ruleGroupUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRuleGroup(id, ruleGroupUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RuleGroupsApi.updateRuleGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.RuleGroupsApiFp = RuleGroupsApiFp;
/**
 * RuleGroupsApi - factory interface
 * @export
 */
const RuleGroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RuleGroupsApiFp)(configuration);
    return {
        /**
         * Delete a rule group.
         * @summary Delete a rule group.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleGroup(id, xTraceId, options) {
            return localVarFp.deleteRuleGroup(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
         * @summary Fire the rule group on your transactions.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
         * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRuleGroup(id, xTraceId, start, end, accounts, options) {
            return localVarFp.fireRuleGroup(id, xTraceId, start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single rule group. This does not include the rules. For that, see below.
         * @summary Get a single rule group.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroup(id, xTraceId, options) {
            return localVarFp.getRuleGroup(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List rules in this rule group.
         * @summary List rules in this rule group.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByGroup(id, xTraceId, limit, page, options) {
            return localVarFp.listRuleByGroup(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rule groups.
         * @summary List all rule groups.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleGroup(xTraceId, limit, page, options) {
            return localVarFp.listRuleGroup(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule group.
         * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRuleGroup(ruleGroupStore, xTraceId, options) {
            return localVarFp.storeRuleGroup(ruleGroupStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule group. No changes will be made.
         * @param {string} id The ID of the rule group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200.
         * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow.
         * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRuleGroup(id, xTraceId, limit, page, start, end, searchLimit, triggeredLimit, accounts, options) {
            return localVarFp.testRuleGroup(id, xTraceId, limit, page, start, end, searchLimit, triggeredLimit, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing rule group.
         * @summary Update existing rule group.
         * @param {string} id The ID of the rule group.
         * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRuleGroup(id, ruleGroupUpdate, xTraceId, options) {
            return localVarFp.updateRuleGroup(id, ruleGroupUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RuleGroupsApiFactory = RuleGroupsApiFactory;
/**
 * RuleGroupsApi - object-oriented interface
 * @export
 * @class RuleGroupsApi
 * @extends {BaseAPI}
 */
class RuleGroupsApi extends base_1.BaseAPI {
    /**
     * Delete a rule group.
     * @summary Delete a rule group.
     * @param {string} id The ID of the rule group.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    deleteRuleGroup(id, xTraceId, options) {
        return (0, exports.RuleGroupsApiFp)(this.configuration).deleteRuleGroup(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
     * @summary Fire the rule group on your transactions.
     * @param {string} id The ID of the rule group.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
     * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    fireRuleGroup(id, xTraceId, start, end, accounts, options) {
        return (0, exports.RuleGroupsApiFp)(this.configuration).fireRuleGroup(id, xTraceId, start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single rule group. This does not include the rules. For that, see below.
     * @summary Get a single rule group.
     * @param {string} id The ID of the rule group.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    getRuleGroup(id, xTraceId, options) {
        return (0, exports.RuleGroupsApiFp)(this.configuration).getRuleGroup(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List rules in this rule group.
     * @summary List rules in this rule group.
     * @param {string} id The ID of the rule group.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    listRuleByGroup(id, xTraceId, limit, page, options) {
        return (0, exports.RuleGroupsApiFp)(this.configuration).listRuleByGroup(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all rule groups.
     * @summary List all rule groups.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    listRuleGroup(xTraceId, limit, page, options) {
        return (0, exports.RuleGroupsApiFp)(this.configuration).listRuleGroup(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new rule group.
     * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    storeRuleGroup(ruleGroupStore, xTraceId, options) {
        return (0, exports.RuleGroupsApiFp)(this.configuration).storeRuleGroup(ruleGroupStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
     * @summary Test which transactions would be hit by the rule group. No changes will be made.
     * @param {string} id The ID of the rule group.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
     * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200.
     * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow.
     * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    testRuleGroup(id, xTraceId, limit, page, start, end, searchLimit, triggeredLimit, accounts, options) {
        return (0, exports.RuleGroupsApiFp)(this.configuration).testRuleGroup(id, xTraceId, limit, page, start, end, searchLimit, triggeredLimit, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing rule group.
     * @summary Update existing rule group.
     * @param {string} id The ID of the rule group.
     * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    updateRuleGroup(id, ruleGroupUpdate, xTraceId, options) {
        return (0, exports.RuleGroupsApiFp)(this.configuration).updateRuleGroup(id, ruleGroupUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RuleGroupsApi = RuleGroupsApi;
/**
 * RulesApi - axios parameter creator
 * @export
 */
const RulesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete an rule.
         * @summary Delete an rule.
         * @param {string} id The ID of the rule.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteRule', 'id', id);
            const localVarPath = `/v1/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
         * @summary Fire the rule on your transactions.
         * @param {string} id The ID of the rule.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present.
         * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRule: (id_1, xTraceId_1, start_1, end_1, accounts_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, start_1, end_1, accounts_1, ...args_1], void 0, function* (id, xTraceId, start, end, accounts, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('fireRule', 'id', id);
            const localVarPath = `/v1/rules/{id}/trigger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single rule.
         * @summary Get a single rule.
         * @param {string} id The ID of the object.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getRule', 'id', id);
            const localVarPath = `/v1/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all rules.
         * @summary List all rules.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRule: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule
         * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRule: (ruleStore_1, xTraceId_1, ...args_1) => __awaiter(this, [ruleStore_1, xTraceId_1, ...args_1], void 0, function* (ruleStore, xTraceId, options = {}) {
            // verify required parameter 'ruleStore' is not null or undefined
            (0, common_1.assertParamExists)('storeRule', 'ruleStore', ruleStore);
            const localVarPath = `/v1/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(ruleStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule. No changes will be made.
         * @param {string} id The ID of the rule.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRule: (id_1, xTraceId_1, start_1, end_1, accounts_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, start_1, end_1, accounts_1, ...args_1], void 0, function* (id, xTraceId, start, end, accounts, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('testRule', 'id', id);
            const localVarPath = `/v1/rules/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing rule.
         * @summary Update existing rule.
         * @param {string} id The ID of the object.
         * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule: (id_1, ruleUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, ruleUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, ruleUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateRule', 'id', id);
            // verify required parameter 'ruleUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateRule', 'ruleUpdate', ruleUpdate);
            const localVarPath = `/v1/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(ruleUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RulesApiAxiosParamCreator = RulesApiAxiosParamCreator;
/**
 * RulesApi - functional programming interface
 * @export
 */
const RulesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RulesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete an rule.
         * @summary Delete an rule.
         * @param {string} id The ID of the rule.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRule(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RulesApi.deleteRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
         * @summary Fire the rule on your transactions.
         * @param {string} id The ID of the rule.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present.
         * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRule(id, xTraceId, start, end, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fireRule(id, xTraceId, start, end, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RulesApi.fireRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single rule.
         * @summary Get a single rule.
         * @param {string} id The ID of the object.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRule(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RulesApi.getRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all rules.
         * @summary List all rules.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRule(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRule(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RulesApi.listRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule
         * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRule(ruleStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeRule(ruleStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RulesApi.storeRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule. No changes will be made.
         * @param {string} id The ID of the rule.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRule(id, xTraceId, start, end, accounts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.testRule(id, xTraceId, start, end, accounts, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RulesApi.testRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing rule.
         * @summary Update existing rule.
         * @param {string} id The ID of the object.
         * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule(id, ruleUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRule(id, ruleUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RulesApi.updateRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.RulesApiFp = RulesApiFp;
/**
 * RulesApi - factory interface
 * @export
 */
const RulesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RulesApiFp)(configuration);
    return {
        /**
         * Delete an rule.
         * @summary Delete an rule.
         * @param {string} id The ID of the rule.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(id, xTraceId, options) {
            return localVarFp.deleteRule(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
         * @summary Fire the rule on your transactions.
         * @param {string} id The ID of the rule.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present.
         * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRule(id, xTraceId, start, end, accounts, options) {
            return localVarFp.fireRule(id, xTraceId, start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single rule.
         * @summary Get a single rule.
         * @param {string} id The ID of the object.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(id, xTraceId, options) {
            return localVarFp.getRule(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rules.
         * @summary List all rules.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRule(xTraceId, limit, page, options) {
            return localVarFp.listRule(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule
         * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRule(ruleStore, xTraceId, options) {
            return localVarFp.storeRule(ruleStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule. No changes will be made.
         * @param {string} id The ID of the rule.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRule(id, xTraceId, start, end, accounts, options) {
            return localVarFp.testRule(id, xTraceId, start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing rule.
         * @summary Update existing rule.
         * @param {string} id The ID of the object.
         * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule(id, ruleUpdate, xTraceId, options) {
            return localVarFp.updateRule(id, ruleUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RulesApiFactory = RulesApiFactory;
/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
class RulesApi extends base_1.BaseAPI {
    /**
     * Delete an rule.
     * @summary Delete an rule.
     * @param {string} id The ID of the rule.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    deleteRule(id, xTraceId, options) {
        return (0, exports.RulesApiFp)(this.configuration).deleteRule(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
     * @summary Fire the rule on your transactions.
     * @param {string} id The ID of the rule.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present.
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present.
     * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    fireRule(id, xTraceId, start, end, accounts, options) {
        return (0, exports.RulesApiFp)(this.configuration).fireRule(id, xTraceId, start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single rule.
     * @summary Get a single rule.
     * @param {string} id The ID of the object.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    getRule(id, xTraceId, options) {
        return (0, exports.RulesApiFp)(this.configuration).getRule(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all rules.
     * @summary List all rules.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    listRule(xTraceId, limit, page, options) {
        return (0, exports.RulesApiFp)(this.configuration).listRule(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new rule
     * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    storeRule(ruleStore, xTraceId, options) {
        return (0, exports.RulesApiFp)(this.configuration).storeRule(ruleStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
     * @summary Test which transactions would be hit by the rule. No changes will be made.
     * @param {string} id The ID of the rule.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
     * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    testRule(id, xTraceId, start, end, accounts, options) {
        return (0, exports.RulesApiFp)(this.configuration).testRule(id, xTraceId, start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing rule.
     * @summary Update existing rule.
     * @param {string} id The ID of the object.
     * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    updateRule(id, ruleUpdate, xTraceId, options) {
        return (0, exports.RulesApiFp)(this.configuration).updateRule(id, ruleUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RulesApi = RulesApi;
/**
 * SearchApi - axios parameter creator
 * @export
 */
const SearchApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Search for accounts
         * @summary Search for accounts
         * @param {string} query The query you wish to search for.
         * @param {AccountSearchFieldFilter} field The account field(s) you want to search in.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {AccountTypeFilter} [type] The type of accounts you wish to limit the search to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts: (query_1, field_1, xTraceId_1, limit_1, page_1, type_1, ...args_1) => __awaiter(this, [query_1, field_1, xTraceId_1, limit_1, page_1, type_1, ...args_1], void 0, function* (query, field, xTraceId, limit, page, type, options = {}) {
            // verify required parameter 'query' is not null or undefined
            (0, common_1.assertParamExists)('searchAccounts', 'query', query);
            // verify required parameter 'field' is not null or undefined
            (0, common_1.assertParamExists)('searchAccounts', 'field', field);
            const localVarPath = `/v1/search/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (field !== undefined) {
                localVarQueryParameter['field'] = field;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Searches through the users transactions.
         * @summary Search for transactions
         * @param {string} query The query you wish to search for.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTransactions: (query_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [query_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (query, xTraceId, limit, page, options = {}) {
            // verify required parameter 'query' is not null or undefined
            (0, common_1.assertParamExists)('searchTransactions', 'query', query);
            const localVarPath = `/v1/search/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SearchApiAxiosParamCreator = SearchApiAxiosParamCreator;
/**
 * SearchApi - functional programming interface
 * @export
 */
const SearchApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SearchApiAxiosParamCreator)(configuration);
    return {
        /**
         * Search for accounts
         * @summary Search for accounts
         * @param {string} query The query you wish to search for.
         * @param {AccountSearchFieldFilter} field The account field(s) you want to search in.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {AccountTypeFilter} [type] The type of accounts you wish to limit the search to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(query, field, xTraceId, limit, page, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchAccounts(query, field, xTraceId, limit, page, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SearchApi.searchAccounts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Searches through the users transactions.
         * @summary Search for transactions
         * @param {string} query The query you wish to search for.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTransactions(query, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchTransactions(query, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SearchApi.searchTransactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.SearchApiFp = SearchApiFp;
/**
 * SearchApi - factory interface
 * @export
 */
const SearchApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SearchApiFp)(configuration);
    return {
        /**
         * Search for accounts
         * @summary Search for accounts
         * @param {string} query The query you wish to search for.
         * @param {AccountSearchFieldFilter} field The account field(s) you want to search in.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {AccountTypeFilter} [type] The type of accounts you wish to limit the search to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(query, field, xTraceId, limit, page, type, options) {
            return localVarFp.searchAccounts(query, field, xTraceId, limit, page, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches through the users transactions.
         * @summary Search for transactions
         * @param {string} query The query you wish to search for.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTransactions(query, xTraceId, limit, page, options) {
            return localVarFp.searchTransactions(query, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SearchApiFactory = SearchApiFactory;
/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
class SearchApi extends base_1.BaseAPI {
    /**
     * Search for accounts
     * @summary Search for accounts
     * @param {string} query The query you wish to search for.
     * @param {AccountSearchFieldFilter} field The account field(s) you want to search in.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {AccountTypeFilter} [type] The type of accounts you wish to limit the search to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    searchAccounts(query, field, xTraceId, limit, page, type, options) {
        return (0, exports.SearchApiFp)(this.configuration).searchAccounts(query, field, xTraceId, limit, page, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches through the users transactions.
     * @summary Search for transactions
     * @param {string} query The query you wish to search for.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    searchTransactions(query, xTraceId, limit, page, options) {
        return (0, exports.SearchApiFp)(this.configuration).searchTransactions(query, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SearchApi = SearchApi;
/**
 * SummaryApi - axios parameter creator
 * @export
 */
const SummaryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is used in Firefly III to populate the dashboard.
         * @summary Returns basic sums of the users data.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [currencyCode] A currency code like EUR or USD, to filter the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicSummary: (start_1, end_1, xTraceId_1, currencyCode_1, ...args_1) => __awaiter(this, [start_1, end_1, xTraceId_1, currencyCode_1, ...args_1], void 0, function* (start, end, xTraceId, currencyCode, options = {}) {
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('getBasicSummary', 'start', start);
            // verify required parameter 'end' is not null or undefined
            (0, common_1.assertParamExists)('getBasicSummary', 'end', end);
            const localVarPath = `/v1/summary/basic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (currencyCode !== undefined) {
                localVarQueryParameter['currency_code'] = currencyCode;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SummaryApiAxiosParamCreator = SummaryApiAxiosParamCreator;
/**
 * SummaryApi - functional programming interface
 * @export
 */
const SummaryApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SummaryApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is used in Firefly III to populate the dashboard.
         * @summary Returns basic sums of the users data.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [currencyCode] A currency code like EUR or USD, to filter the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicSummary(start, end, xTraceId, currencyCode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBasicSummary(start, end, xTraceId, currencyCode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SummaryApi.getBasicSummary']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.SummaryApiFp = SummaryApiFp;
/**
 * SummaryApi - factory interface
 * @export
 */
const SummaryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SummaryApiFp)(configuration);
    return {
        /**
         * Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is used in Firefly III to populate the dashboard.
         * @summary Returns basic sums of the users data.
         * @param {string} start A date formatted YYYY-MM-DD.
         * @param {string} end A date formatted YYYY-MM-DD.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [currencyCode] A currency code like EUR or USD, to filter the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicSummary(start, end, xTraceId, currencyCode, options) {
            return localVarFp.getBasicSummary(start, end, xTraceId, currencyCode, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SummaryApiFactory = SummaryApiFactory;
/**
 * SummaryApi - object-oriented interface
 * @export
 * @class SummaryApi
 * @extends {BaseAPI}
 */
class SummaryApi extends base_1.BaseAPI {
    /**
     * Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is used in Firefly III to populate the dashboard.
     * @summary Returns basic sums of the users data.
     * @param {string} start A date formatted YYYY-MM-DD.
     * @param {string} end A date formatted YYYY-MM-DD.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {string} [currencyCode] A currency code like EUR or USD, to filter the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummaryApi
     */
    getBasicSummary(start, end, xTraceId, currencyCode, options) {
        return (0, exports.SummaryApiFp)(this.configuration).getBasicSummary(start, end, xTraceId, currencyCode, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SummaryApi = SummaryApi;
/**
 * TagsApi - axios parameter creator
 * @export
 */
const TagsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete an tag.
         * @summary Delete an tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: (tag_1, xTraceId_1, ...args_1) => __awaiter(this, [tag_1, xTraceId_1, ...args_1], void 0, function* (tag, xTraceId, options = {}) {
            // verify required parameter 'tag' is not null or undefined
            (0, common_1.assertParamExists)('deleteTag', 'tag', tag);
            const localVarPath = `/v1/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single tag.
         * @summary Get a single tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: (tag_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [tag_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (tag, xTraceId, limit, page, options = {}) {
            // verify required parameter 'tag' is not null or undefined
            (0, common_1.assertParamExists)('getTag', 'tag', tag);
            const localVarPath = `/v1/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTag: (tag_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [tag_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (tag, xTraceId, limit, page, options = {}) {
            // verify required parameter 'tag' is not null or undefined
            (0, common_1.assertParamExists)('listAttachmentByTag', 'tag', tag);
            const localVarPath = `/v1/tags/{tag}/attachments`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all of the user\'s tags.
         * @summary List all tags.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTag: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all transactions with this tag.
         * @summary List all transactions with this tag.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByTag: (tag_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1) => __awaiter(this, [tag_1, xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1], void 0, function* (tag, xTraceId, limit, page, start, end, type, options = {}) {
            // verify required parameter 'tag' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionByTag', 'tag', tag);
            const localVarPath = `/v1/tags/{tag}/transactions`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new tag
         * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTag: (tagModelStore_1, xTraceId_1, ...args_1) => __awaiter(this, [tagModelStore_1, xTraceId_1, ...args_1], void 0, function* (tagModelStore, xTraceId, options = {}) {
            // verify required parameter 'tagModelStore' is not null or undefined
            (0, common_1.assertParamExists)('storeTag', 'tagModelStore', tagModelStore);
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tagModelStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing tag.
         * @summary Update existing tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: (tag_1, tagModelUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [tag_1, tagModelUpdate_1, xTraceId_1, ...args_1], void 0, function* (tag, tagModelUpdate, xTraceId, options = {}) {
            // verify required parameter 'tag' is not null or undefined
            (0, common_1.assertParamExists)('updateTag', 'tag', tag);
            // verify required parameter 'tagModelUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateTag', 'tagModelUpdate', tagModelUpdate);
            const localVarPath = `/v1/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tagModelUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TagsApiAxiosParamCreator = TagsApiAxiosParamCreator;
/**
 * TagsApi - functional programming interface
 * @export
 */
const TagsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TagsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete an tag.
         * @summary Delete an tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tag, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTag(tag, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TagsApi.deleteTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single tag.
         * @summary Get a single tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tag, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTag(tag, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TagsApi.getTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTag(tag, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAttachmentByTag(tag, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TagsApi.listAttachmentByTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all of the user\'s tags.
         * @summary List all tags.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTag(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTag(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TagsApi.listTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all transactions with this tag.
         * @summary List all transactions with this tag.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByTag(tag, xTraceId, limit, page, start, end, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionByTag(tag, xTraceId, limit, page, start, end, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TagsApi.listTransactionByTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new tag
         * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTag(tagModelStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeTag(tagModelStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TagsApi.storeTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing tag.
         * @summary Update existing tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tag, tagModelUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTag(tag, tagModelUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TagsApi.updateTag']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.TagsApiFp = TagsApiFp;
/**
 * TagsApi - factory interface
 * @export
 */
const TagsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TagsApiFp)(configuration);
    return {
        /**
         * Delete an tag.
         * @summary Delete an tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tag, xTraceId, options) {
            return localVarFp.deleteTag(tag, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single tag.
         * @summary Get a single tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tag, xTraceId, limit, page, options) {
            return localVarFp.getTag(tag, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTag(tag, xTraceId, limit, page, options) {
            return localVarFp.listAttachmentByTag(tag, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the user\'s tags.
         * @summary List all tags.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTag(xTraceId, limit, page, options) {
            return localVarFp.listTag(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions with this tag.
         * @summary List all transactions with this tag.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByTag(tag, xTraceId, limit, page, start, end, type, options) {
            return localVarFp.listTransactionByTag(tag, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new tag
         * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTag(tagModelStore, xTraceId, options) {
            return localVarFp.storeTag(tagModelStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing tag.
         * @summary Update existing tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tag, tagModelUpdate, xTraceId, options) {
            return localVarFp.updateTag(tag, tagModelUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TagsApiFactory = TagsApiFactory;
/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
class TagsApi extends base_1.BaseAPI {
    /**
     * Delete an tag.
     * @summary Delete an tag.
     * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    deleteTag(tag, xTraceId, options) {
        return (0, exports.TagsApiFp)(this.configuration).deleteTag(tag, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single tag.
     * @summary Get a single tag.
     * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    getTag(tag, xTraceId, limit, page, options) {
        return (0, exports.TagsApiFp)(this.configuration).getTag(tag, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} tag Either the tag itself or the tag ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    listAttachmentByTag(tag, xTraceId, limit, page, options) {
        return (0, exports.TagsApiFp)(this.configuration).listAttachmentByTag(tag, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all of the user\'s tags.
     * @summary List all tags.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    listTag(xTraceId, limit, page, options) {
        return (0, exports.TagsApiFp)(this.configuration).listTag(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all transactions with this tag.
     * @summary List all transactions with this tag.
     * @param {string} tag Either the tag itself or the tag ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
     * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    listTransactionByTag(tag, xTraceId, limit, page, start, end, type, options) {
        return (0, exports.TagsApiFp)(this.configuration).listTransactionByTag(tag, xTraceId, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new tag
     * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    storeTag(tagModelStore, xTraceId, options) {
        return (0, exports.TagsApiFp)(this.configuration).storeTag(tagModelStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing tag.
     * @summary Update existing tag.
     * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
     * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    updateTag(tag, tagModelUpdate, xTraceId, options) {
        return (0, exports.TagsApiFp)(this.configuration).updateTag(tag, tagModelUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TagsApi = TagsApi;
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteTransaction', 'id', id);
            const localVarPath = `/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionJournal: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteTransactionJournal', 'id', id);
            const localVarPath = `/v1/transaction-journals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTransaction', 'id', id);
            const localVarPath = `/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByJournal: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionByJournal', 'id', id);
            const localVarPath = `/v1/transaction-journals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTransaction: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listAttachmentByTransaction', 'id', id);
            const localVarPath = `/v1/transactions/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByTransaction: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listEventByTransaction', 'id', id);
            const localVarPath = `/v1/transactions/{id}/piggy-bank-events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinksByJournal: (id_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listLinksByJournal', 'id', id);
            const localVarPath = `/v1/transaction-journals/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransaction: (xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, start_1, end_1, type_1, ...args_1], void 0, function* (xTraceId, limit, page, start, end, type, options = {}) {
            const localVarPath = `/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString().substring(0, 10) :
                    start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = (end instanceof Date) ?
                    end.toISOString().substring(0, 10) :
                    end;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransaction: (transactionStore_1, xTraceId_1, ...args_1) => __awaiter(this, [transactionStore_1, xTraceId_1, ...args_1], void 0, function* (transactionStore, xTraceId, options = {}) {
            // verify required parameter 'transactionStore' is not null or undefined
            (0, common_1.assertParamExists)('storeTransaction', 'transactionStore', transactionStore);
            const localVarPath = `/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: (id_1, transactionUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, transactionUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, transactionUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateTransaction', 'id', id);
            // verify required parameter 'transactionUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateTransaction', 'transactionUpdate', transactionUpdate);
            const localVarPath = `/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransactionsApiAxiosParamCreator = TransactionsApiAxiosParamCreator;
/**
 * TransactionsApi - functional programming interface
 * @export
 */
const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransactionsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTransaction(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.deleteTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionJournal(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTransactionJournal(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.deleteTransactionJournal']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransaction(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.getTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByJournal(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionByJournal(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.getTransactionByJournal']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTransaction(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAttachmentByTransaction(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.listAttachmentByTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByTransaction(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listEventByTransaction(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.listEventByTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinksByJournal(id, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listLinksByJournal(id, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.listLinksByJournal']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransaction(xTraceId, limit, page, start, end, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransaction(xTraceId, limit, page, start, end, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.listTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransaction(transactionStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeTransaction(transactionStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.storeTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id, transactionUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTransaction(id, transactionUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.updateTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.TransactionsApiFp = TransactionsApiFp;
/**
 * TransactionsApi - factory interface
 * @export
 */
const TransactionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransactionsApiFp)(configuration);
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id, xTraceId, options) {
            return localVarFp.deleteTransaction(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionJournal(id, xTraceId, options) {
            return localVarFp.deleteTransactionJournal(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(id, xTraceId, options) {
            return localVarFp.getTransaction(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByJournal(id, xTraceId, options) {
            return localVarFp.getTransactionByJournal(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTransaction(id, xTraceId, limit, page, options) {
            return localVarFp.listAttachmentByTransaction(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByTransaction(id, xTraceId, limit, page, options) {
            return localVarFp.listEventByTransaction(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinksByJournal(id, xTraceId, limit, page, options) {
            return localVarFp.listLinksByJournal(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransaction(xTraceId, limit, page, start, end, type, options) {
            return localVarFp.listTransaction(xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransaction(transactionStore, xTraceId, options) {
            return localVarFp.storeTransaction(transactionStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id, transactionUpdate, xTraceId, options) {
            return localVarFp.updateTransaction(id, transactionUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransactionsApiFactory = TransactionsApiFactory;
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends base_1.BaseAPI {
    /**
     * Delete a transaction.
     * @summary Delete a transaction.
     * @param {string} id The ID of the transaction.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    deleteTransaction(id, xTraceId, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).deleteTransaction(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an individual journal (split) from a transaction.
     * @summary Delete split from transaction
     * @param {string} id The ID of the transaction journal (the split) you wish to delete.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    deleteTransactionJournal(id, xTraceId, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).deleteTransactionJournal(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single transaction.
     * @summary Get a single transaction.
     * @param {string} id The ID of the transaction.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransaction(id, xTraceId, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).getTransaction(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single transaction by underlying journal (split).
     * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
     * @param {string} id The ID of the transaction journal (split).
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionByJournal(id, xTraceId, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).getTransactionByJournal(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} id The ID of the transaction.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    listAttachmentByTransaction(id, xTraceId, limit, page, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).listAttachmentByTransaction(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all piggy bank events.
     * @summary Lists all piggy bank events.
     * @param {string} id The ID of the transaction.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    listEventByTransaction(id, xTraceId, limit, page, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).listEventByTransaction(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
     * @summary Lists all the transaction links for an individual journal (individual split).
     * @param {string} id The ID of the transaction journal / the split.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    listLinksByJournal(id, xTraceId, limit, page, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).listLinksByJournal(id, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all the user\'s transactions.
     * @summary List all the user\'s transactions.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
     * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    listTransaction(xTraceId, limit, page, start, end, type, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).listTransaction(xTraceId, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new transaction
     * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    storeTransaction(transactionStore, xTraceId, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).storeTransaction(transactionStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an existing transaction.
     * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
     * @param {string} id The ID of the transaction.
     * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    updateTransaction(id, transactionUpdate, xTraceId, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).updateTransaction(id, transactionUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransactionsApi = TransactionsApi;
/**
 * UserGroupsApi - axios parameter creator
 * @export
 */
const UserGroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a single user group by its ID.
         * @summary Get a single user group.
         * @param {string} id The ID of the user group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroup: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUserGroup', 'id', id);
            const localVarPath = `/v1/user-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all the user groups available to this user. These are essentially the \'financial administrations\' that Firefly III supports.
         * @summary List all the user groups available to this user.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserGroups: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/user-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Used to update a single user group. The available fields are still limited.
         * @summary Update an existing user group.
         * @param {string} id The ID of the account.
         * @param {UserGroupUpdate} userGroupUpdate JSON array or formdata with new user group information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup: (id_1, userGroupUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, userGroupUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, userGroupUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserGroup', 'id', id);
            // verify required parameter 'userGroupUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateUserGroup', 'userGroupUpdate', userGroupUpdate);
            const localVarPath = `/v1/user-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(userGroupUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserGroupsApiAxiosParamCreator = UserGroupsApiAxiosParamCreator;
/**
 * UserGroupsApi - functional programming interface
 * @export
 */
const UserGroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserGroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a single user group by its ID.
         * @summary Get a single user group.
         * @param {string} id The ID of the user group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroup(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserGroup(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserGroupsApi.getUserGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all the user groups available to this user. These are essentially the \'financial administrations\' that Firefly III supports.
         * @summary List all the user groups available to this user.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserGroups(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUserGroups(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserGroupsApi.listUserGroups']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Used to update a single user group. The available fields are still limited.
         * @summary Update an existing user group.
         * @param {string} id The ID of the account.
         * @param {UserGroupUpdate} userGroupUpdate JSON array or formdata with new user group information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup(id, userGroupUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserGroup(id, userGroupUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserGroupsApi.updateUserGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.UserGroupsApiFp = UserGroupsApiFp;
/**
 * UserGroupsApi - factory interface
 * @export
 */
const UserGroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserGroupsApiFp)(configuration);
    return {
        /**
         * Returns a single user group by its ID.
         * @summary Get a single user group.
         * @param {string} id The ID of the user group.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroup(id, xTraceId, options) {
            return localVarFp.getUserGroup(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user groups available to this user. These are essentially the \'financial administrations\' that Firefly III supports.
         * @summary List all the user groups available to this user.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserGroups(xTraceId, limit, page, options) {
            return localVarFp.listUserGroups(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a single user group. The available fields are still limited.
         * @summary Update an existing user group.
         * @param {string} id The ID of the account.
         * @param {UserGroupUpdate} userGroupUpdate JSON array or formdata with new user group information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup(id, userGroupUpdate, xTraceId, options) {
            return localVarFp.updateUserGroup(id, userGroupUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserGroupsApiFactory = UserGroupsApiFactory;
/**
 * UserGroupsApi - object-oriented interface
 * @export
 * @class UserGroupsApi
 * @extends {BaseAPI}
 */
class UserGroupsApi extends base_1.BaseAPI {
    /**
     * Returns a single user group by its ID.
     * @summary Get a single user group.
     * @param {string} id The ID of the user group.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsApi
     */
    getUserGroup(id, xTraceId, options) {
        return (0, exports.UserGroupsApiFp)(this.configuration).getUserGroup(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all the user groups available to this user. These are essentially the \'financial administrations\' that Firefly III supports.
     * @summary List all the user groups available to this user.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsApi
     */
    listUserGroups(xTraceId, limit, page, options) {
        return (0, exports.UserGroupsApiFp)(this.configuration).listUserGroups(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Used to update a single user group. The available fields are still limited.
     * @summary Update an existing user group.
     * @param {string} id The ID of the account.
     * @param {UserGroupUpdate} userGroupUpdate JSON array or formdata with new user group information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsApi
     */
    updateUserGroup(id, userGroupUpdate, xTraceId, options) {
        return (0, exports.UserGroupsApiFp)(this.configuration).updateUserGroup(id, userGroupUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserGroupsApi = UserGroupsApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
const UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a user. You cannot delete the user you\'re authenticated with. This cannot be undone. Be careful!
         * @summary Delete a user.
         * @param {string} id The user ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteUser', 'id', id);
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets all info of a single user.
         * @summary Get a single user.
         * @param {string} id The user ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUser', 'id', id);
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all the users in this instance of Firefly III.
         * @summary List all users.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUser: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the \"forgot password\" function.
         * @summary Store a new user
         * @param {User} user JSON array or key&#x3D;value pairs with the necessary user information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeUser: (user_1, xTraceId_1, ...args_1) => __awaiter(this, [user_1, xTraceId_1, ...args_1], void 0, function* (user, xTraceId, options = {}) {
            // verify required parameter 'user' is not null or undefined
            (0, common_1.assertParamExists)('storeUser', 'user', user);
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(user, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update existing user.
         * @summary Update an existing user\'s information.
         * @param {string} id The user ID.
         * @param {User} user JSON array with updated user information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: (id_1, user_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, user_1, xTraceId_1, ...args_1], void 0, function* (id, user, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'id', id);
            // verify required parameter 'user' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'user', user);
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(user, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;
/**
 * UsersApi - functional programming interface
 * @export
 */
const UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a user. You cannot delete the user you\'re authenticated with. This cannot be undone. Be careful!
         * @summary Delete a user.
         * @param {string} id The user ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUser(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.deleteUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Gets all info of a single user.
         * @summary Get a single user.
         * @param {string} id The user ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUser(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all the users in this instance of Firefly III.
         * @summary List all users.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUser(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUser(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.listUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the \"forgot password\" function.
         * @summary Store a new user
         * @param {User} user JSON array or key&#x3D;value pairs with the necessary user information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeUser(user, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeUser(user, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.storeUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update existing user.
         * @summary Update an existing user\'s information.
         * @param {string} id The user ID.
         * @param {User} user JSON array with updated user information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id, user, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUser(id, user, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.updateUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.UsersApiFp = UsersApiFp;
/**
 * UsersApi - factory interface
 * @export
 */
const UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UsersApiFp)(configuration);
    return {
        /**
         * Delete a user. You cannot delete the user you\'re authenticated with. This cannot be undone. Be careful!
         * @summary Delete a user.
         * @param {string} id The user ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id, xTraceId, options) {
            return localVarFp.deleteUser(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all info of a single user.
         * @summary Get a single user.
         * @param {string} id The user ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id, xTraceId, options) {
            return localVarFp.getUser(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the users in this instance of Firefly III.
         * @summary List all users.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUser(xTraceId, limit, page, options) {
            return localVarFp.listUser(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the \"forgot password\" function.
         * @summary Store a new user
         * @param {User} user JSON array or key&#x3D;value pairs with the necessary user information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeUser(user, xTraceId, options) {
            return localVarFp.storeUser(user, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing user.
         * @summary Update an existing user\'s information.
         * @param {string} id The user ID.
         * @param {User} user JSON array with updated user information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id, user, xTraceId, options) {
            return localVarFp.updateUser(id, user, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UsersApiFactory = UsersApiFactory;
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     * Delete a user. You cannot delete the user you\'re authenticated with. This cannot be undone. Be careful!
     * @summary Delete a user.
     * @param {string} id The user ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUser(id, xTraceId, options) {
        return (0, exports.UsersApiFp)(this.configuration).deleteUser(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets all info of a single user.
     * @summary Get a single user.
     * @param {string} id The user ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUser(id, xTraceId, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUser(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all the users in this instance of Firefly III.
     * @summary List all users.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    listUser(xTraceId, limit, page, options) {
        return (0, exports.UsersApiFp)(this.configuration).listUser(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the \"forgot password\" function.
     * @summary Store a new user
     * @param {User} user JSON array or key&#x3D;value pairs with the necessary user information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    storeUser(user, xTraceId, options) {
        return (0, exports.UsersApiFp)(this.configuration).storeUser(user, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update existing user.
     * @summary Update an existing user\'s information.
     * @param {string} id The user ID.
     * @param {User} user JSON array with updated user information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUser(id, user, xTraceId, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUser(id, user, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
const WebhooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a webhook.
         * @summary Delete a webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhook', 'id', id);
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
         * @summary Delete a webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessage: (id_1, messageId_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, messageId_1, xTraceId_1, ...args_1], void 0, function* (id, messageId, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhookMessage', 'id', id);
            // verify required parameter 'messageId' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhookMessage', 'messageId', messageId);
            const localVarPath = `/v1/webhooks/{id}/messages/{messageId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
         * @summary Delete a webhook attempt.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook message attempt ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessageAttempt: (id_1, messageId_1, attemptId_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, messageId_1, attemptId_1, xTraceId_1, ...args_1], void 0, function* (id, messageId, attemptId, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhookMessageAttempt', 'id', id);
            // verify required parameter 'messageId' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhookMessageAttempt', 'messageId', messageId);
            // verify required parameter 'attemptId' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhookMessageAttempt', 'attemptId', attemptId);
            const localVarPath = `/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"attemptId"}}`, encodeURIComponent(String(attemptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
         * @summary Get a single message from a webhook.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessage: (id_1, messageId_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, messageId_1, xTraceId_1, ...args_1], void 0, function* (id, messageId, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleWebhookMessage', 'id', id);
            // verify required parameter 'messageId' is not null or undefined
            (0, common_1.assertParamExists)('getSingleWebhookMessage', 'messageId', messageId);
            const localVarPath = `/v1/webhooks/{id}/messages/{messageId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
         * @summary Get a single failed attempt from a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook attempt ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessageAttempt: (id_1, messageId_1, attemptId_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, messageId_1, attemptId_1, xTraceId_1, ...args_1], void 0, function* (id, messageId, attemptId, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleWebhookMessageAttempt', 'id', id);
            // verify required parameter 'messageId' is not null or undefined
            (0, common_1.assertParamExists)('getSingleWebhookMessageAttempt', 'messageId', messageId);
            // verify required parameter 'attemptId' is not null or undefined
            (0, common_1.assertParamExists)('getSingleWebhookMessageAttempt', 'attemptId', attemptId);
            const localVarPath = `/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"attemptId"}}`, encodeURIComponent(String(attemptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets all info of a single webhook.
         * @summary Get a single webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getWebhook', 'id', id);
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
         * @summary Get all the failed attempts of a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessageAttempts: (id_1, messageId_1, xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [id_1, messageId_1, xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (id, messageId, xTraceId, limit, page, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getWebhookMessageAttempts', 'id', id);
            // verify required parameter 'messageId' is not null or undefined
            (0, common_1.assertParamExists)('getWebhookMessageAttempts', 'messageId', messageId);
            const localVarPath = `/v1/webhooks/{id}/messages/{messageId}/attempts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
         * @summary Get all the messages of a single webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getWebhookMessages', 'id', id);
            const localVarPath = `/v1/webhooks/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all the user\'s webhooks.
         * @summary List all webhooks.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhook: (xTraceId_1, limit_1, page_1, ...args_1) => __awaiter(this, [xTraceId_1, limit_1, page_1, ...args_1], void 0, function* (xTraceId, limit, page, options = {}) {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret.
         * @summary Store a new webhook
         * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebhook: (webhookStore_1, xTraceId_1, ...args_1) => __awaiter(this, [webhookStore_1, xTraceId_1, ...args_1], void 0, function* (webhookStore, xTraceId, options = {}) {
            // verify required parameter 'webhookStore' is not null or undefined
            (0, common_1.assertParamExists)('storeWebhook', 'webhookStore', webhookStore);
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookStore, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Submit messages for a webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWebook: (id_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, xTraceId_1, ...args_1], void 0, function* (id, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('submitWebook', 'id', id);
            const localVarPath = `/v1/webhooks/{id}/submit`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will execute this webhook for a given transaction ID. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Trigger webhook for a given transaction.
         * @param {string} id The webhook ID.
         * @param {string} transactionId The transaction ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTransactionWebhook: (id_1, transactionId_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, transactionId_1, xTraceId_1, ...args_1], void 0, function* (id, transactionId, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('triggerTransactionWebhook', 'id', id);
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('triggerTransactionWebhook', 'transactionId', transactionId);
            const localVarPath = `/v1/webhooks/{id}/trigger-transaction/{transactionId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
         * @summary Update existing webhook.
         * @param {string} id The webhook ID.
         * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: (id_1, webhookUpdate_1, xTraceId_1, ...args_1) => __awaiter(this, [id_1, webhookUpdate_1, xTraceId_1, ...args_1], void 0, function* (id, webhookUpdate, xTraceId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateWebhook', 'id', id);
            // verify required parameter 'webhookUpdate' is not null or undefined
            (0, common_1.assertParamExists)('updateWebhook', 'webhookUpdate', webhookUpdate);
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication firefly_iii_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "firefly_iii_auth", [], configuration);
            // authentication local_bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (xTraceId != null) {
                localVarHeaderParameter['X-Trace-Id'] = String(xTraceId);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookUpdate, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.WebhooksApiAxiosParamCreator = WebhooksApiAxiosParamCreator;
/**
 * WebhooksApi - functional programming interface
 * @export
 */
const WebhooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WebhooksApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a webhook.
         * @summary Delete a webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWebhook(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.deleteWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
         * @summary Delete a webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessage(id, messageId, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWebhookMessage(id, messageId, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.deleteWebhookMessage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
         * @summary Delete a webhook attempt.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook message attempt ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.deleteWebhookMessageAttempt']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
         * @summary Get a single message from a webhook.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessage(id, messageId, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleWebhookMessage(id, messageId, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.getSingleWebhookMessage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
         * @summary Get a single failed attempt from a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook attempt ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.getSingleWebhookMessageAttempt']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Gets all info of a single webhook.
         * @summary Get a single webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWebhook(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.getWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
         * @summary Get all the failed attempts of a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessageAttempts(id, messageId, xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWebhookMessageAttempts(id, messageId, xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.getWebhookMessageAttempts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
         * @summary Get all the messages of a single webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWebhookMessages(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.getWebhookMessages']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all the user\'s webhooks.
         * @summary List all webhooks.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhook(xTraceId, limit, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWebhook(xTraceId, limit, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.listWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret.
         * @summary Store a new webhook
         * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebhook(webhookStore, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeWebhook(webhookStore, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.storeWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Submit messages for a webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWebook(id, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitWebook(id, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.submitWebook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint will execute this webhook for a given transaction ID. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Trigger webhook for a given transaction.
         * @param {string} id The webhook ID.
         * @param {string} transactionId The transaction ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTransactionWebhook(id, transactionId, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.triggerTransactionWebhook(id, transactionId, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.triggerTransactionWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
         * @summary Update existing webhook.
         * @param {string} id The webhook ID.
         * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(id, webhookUpdate, xTraceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWebhook(id, webhookUpdate, xTraceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.updateWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.WebhooksApiFp = WebhooksApiFp;
/**
 * WebhooksApi - factory interface
 * @export
 */
const WebhooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WebhooksApiFp)(configuration);
    return {
        /**
         * Delete a webhook.
         * @summary Delete a webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id, xTraceId, options) {
            return localVarFp.deleteWebhook(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
         * @summary Delete a webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessage(id, messageId, xTraceId, options) {
            return localVarFp.deleteWebhookMessage(id, messageId, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
         * @summary Delete a webhook attempt.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook message attempt ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options) {
            return localVarFp.deleteWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
         * @summary Get a single message from a webhook.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessage(id, messageId, xTraceId, options) {
            return localVarFp.getSingleWebhookMessage(id, messageId, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
         * @summary Get a single failed attempt from a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook attempt ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options) {
            return localVarFp.getSingleWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all info of a single webhook.
         * @summary Get a single webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id, xTraceId, options) {
            return localVarFp.getWebhook(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
         * @summary Get all the failed attempts of a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessageAttempts(id, messageId, xTraceId, limit, page, options) {
            return localVarFp.getWebhookMessageAttempts(id, messageId, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
         * @summary Get all the messages of a single webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages(id, xTraceId, options) {
            return localVarFp.getWebhookMessages(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user\'s webhooks.
         * @summary List all webhooks.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhook(xTraceId, limit, page, options) {
            return localVarFp.listWebhook(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret.
         * @summary Store a new webhook
         * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebhook(webhookStore, xTraceId, options) {
            return localVarFp.storeWebhook(webhookStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Submit messages for a webhook.
         * @param {string} id The webhook ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWebook(id, xTraceId, options) {
            return localVarFp.submitWebook(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will execute this webhook for a given transaction ID. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Trigger webhook for a given transaction.
         * @param {string} id The webhook ID.
         * @param {string} transactionId The transaction ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTransactionWebhook(id, transactionId, xTraceId, options) {
            return localVarFp.triggerTransactionWebhook(id, transactionId, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
         * @summary Update existing webhook.
         * @param {string} id The webhook ID.
         * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(id, webhookUpdate, xTraceId, options) {
            return localVarFp.updateWebhook(id, webhookUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WebhooksApiFactory = WebhooksApiFactory;
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
class WebhooksApi extends base_1.BaseAPI {
    /**
     * Delete a webhook.
     * @summary Delete a webhook.
     * @param {string} id The webhook ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhook(id, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).deleteWebhook(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
     * @summary Delete a webhook message.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhookMessage(id, messageId, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).deleteWebhookMessage(id, messageId, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
     * @summary Delete a webhook attempt.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {number} attemptId The webhook message attempt ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).deleteWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
     * @summary Get a single message from a webhook.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getSingleWebhookMessage(id, messageId, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).getSingleWebhookMessage(id, messageId, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
     * @summary Get a single failed attempt from a single webhook message.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {number} attemptId The webhook attempt ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getSingleWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).getSingleWebhookMessageAttempt(id, messageId, attemptId, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets all info of a single webhook.
     * @summary Get a single webhook.
     * @param {string} id The webhook ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhook(id, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).getWebhook(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
     * @summary Get all the failed attempts of a single webhook message.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhookMessageAttempts(id, messageId, xTraceId, limit, page, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).getWebhookMessageAttempts(id, messageId, xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
     * @summary Get all the messages of a single webhook.
     * @param {string} id The webhook ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhookMessages(id, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).getWebhookMessages(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all the user\'s webhooks.
     * @summary List all webhooks.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listWebhook(xTraceId, limit, page, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).listWebhook(xTraceId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret.
     * @summary Store a new webhook
     * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    storeWebhook(webhookStore, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).storeWebhook(webhookStore, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
     * @summary Submit messages for a webhook.
     * @param {string} id The webhook ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    submitWebook(id, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).submitWebook(id, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will execute this webhook for a given transaction ID. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
     * @summary Trigger webhook for a given transaction.
     * @param {string} id The webhook ID.
     * @param {string} transactionId The transaction ID.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    triggerTransactionWebhook(id, transactionId, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).triggerTransactionWebhook(id, transactionId, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
     * @summary Update existing webhook.
     * @param {string} id The webhook ID.
     * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
     * @param {string} [xTraceId] Unique identifier associated with this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    updateWebhook(id, webhookUpdate, xTraceId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).updateWebhook(id, webhookUpdate, xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WebhooksApi = WebhooksApi;
