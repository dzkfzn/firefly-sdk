"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v6.2.21
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2025-07-18T05:50:30+00:00 Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that.
 *
 * The version of the OpenAPI document: v6.2.21
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinksApi = void 0;
const runtime = __importStar(require("../runtime"));
const index_1 = require("../models/index");
/**
 *
 */
class LinksApi extends runtime.BaseAPI {
    /**
     * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it.
     * Permanently delete link type.
     */
    deleteLinkTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling deleteLinkType().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/link-types/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.VoidApiResponse(response);
        });
    }
    /**
     * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it.
     * Permanently delete link type.
     */
    deleteLinkType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteLinkTypeRaw(requestParameters, initOverrides);
        });
    }
    /**
     * Will permanently delete link. Transactions remain.
     * Permanently delete link between transactions.
     */
    deleteTransactionLinkRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling deleteTransactionLink().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/transaction-links/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.VoidApiResponse(response);
        });
    }
    /**
     * Will permanently delete link. Transactions remain.
     * Permanently delete link between transactions.
     */
    deleteTransactionLink(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteTransactionLinkRaw(requestParameters, initOverrides);
        });
    }
    /**
     * Returns a single link type by its ID.
     * Get single a link type.
     */
    getLinkTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling getLinkType().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/link-types/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.LinkTypeSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Returns a single link type by its ID.
     * Get single a link type.
     */
    getLinkType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getLinkTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns a single link by its ID.
     * Get a single link.
     */
    getTransactionLinkRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling getTransactionLink().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/transaction-links/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.TransactionLinkSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Returns a single link by its ID.
     * Get a single link.
     */
    getTransactionLink(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getTransactionLinkRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * List all the link types the system has. These include the default ones as well as any new ones.
     * List all types of links.
     */
    listLinkTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters['limit'] != null) {
                queryParameters['limit'] = requestParameters['limit'];
            }
            if (requestParameters['page'] != null) {
                queryParameters['page'] = requestParameters['page'];
            }
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/link-types`;
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.LinkTypeArrayFromJSON)(jsonValue));
        });
    }
    /**
     * List all the link types the system has. These include the default ones as well as any new ones.
     * List all types of links.
     */
    listLinkType() {
        return __awaiter(this, arguments, void 0, function* (requestParameters = {}, initOverrides) {
            const response = yield this.listLinkTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * List all transactions under this link type, both the inward and outward transactions.
     * List all transactions under this link type.
     */
    listTransactionByLinkTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling listTransactionByLinkType().');
            }
            const queryParameters = {};
            if (requestParameters['limit'] != null) {
                queryParameters['limit'] = requestParameters['limit'];
            }
            if (requestParameters['page'] != null) {
                queryParameters['page'] = requestParameters['page'];
            }
            if (requestParameters['start'] != null) {
                queryParameters['start'] = requestParameters['start'].toISOString().substring(0, 10);
            }
            if (requestParameters['end'] != null) {
                queryParameters['end'] = requestParameters['end'].toISOString().substring(0, 10);
            }
            if (requestParameters['type'] != null) {
                queryParameters['type'] = requestParameters['type'];
            }
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/link-types/{id}/transactions`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.TransactionArrayFromJSON)(jsonValue));
        });
    }
    /**
     * List all transactions under this link type, both the inward and outward transactions.
     * List all transactions under this link type.
     */
    listTransactionByLinkType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listTransactionByLinkTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * List all the transaction links.
     * List all transaction links.
     */
    listTransactionLinkRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters['limit'] != null) {
                queryParameters['limit'] = requestParameters['limit'];
            }
            if (requestParameters['page'] != null) {
                queryParameters['page'] = requestParameters['page'];
            }
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/transaction-links`;
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.TransactionLinkArrayFromJSON)(jsonValue));
        });
    }
    /**
     * List all the transaction links.
     * List all transaction links.
     */
    listTransactionLink() {
        return __awaiter(this, arguments, void 0, function* (requestParameters = {}, initOverrides) {
            const response = yield this.listTransactionLinkRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
     * Create a new link type
     */
    storeLinkTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['linkType'] == null) {
                throw new runtime.RequiredError('linkType', 'Required parameter "linkType" was null or undefined when calling storeLinkType().');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/link-types`;
            const response = yield this.request({
                path: urlPath,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.LinkTypeToJSON)(requestParameters['linkType']),
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.LinkTypeSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
     * Create a new link type
     */
    storeLinkType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.storeLinkTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
     * Create a new link between transactions
     */
    storeTransactionLinkRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['transactionLinkStore'] == null) {
                throw new runtime.RequiredError('transactionLinkStore', 'Required parameter "transactionLinkStore" was null or undefined when calling storeTransactionLink().');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/transaction-links`;
            const response = yield this.request({
                path: urlPath,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.TransactionLinkStoreToJSON)(requestParameters['transactionLinkStore']),
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.TransactionLinkSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
     * Create a new link between transactions
     */
    storeTransactionLink(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.storeTransactionLinkRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Used to update a single currency exchange rate
     * Update existing currency exchange rate.
     */
    updateCurrencyExchangeRateRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling updateCurrencyExchangeRate().');
            }
            if (requestParameters['currencyExchangeRateUpdate'] == null) {
                throw new runtime.RequiredError('currencyExchangeRateUpdate', 'Required parameter "currencyExchangeRateUpdate" was null or undefined when calling updateCurrencyExchangeRate().');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/exchange-rates/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.CurrencyExchangeRateUpdateToJSON)(requestParameters['currencyExchangeRateUpdate']),
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.CurrencyExchangeRateSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Used to update a single currency exchange rate
     * Update existing currency exchange rate.
     */
    updateCurrencyExchangeRate(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateCurrencyExchangeRateRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it.
     * Update existing link type.
     */
    updateLinkTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling updateLinkType().');
            }
            if (requestParameters['linkTypeUpdate'] == null) {
                throw new runtime.RequiredError('linkTypeUpdate', 'Required parameter "linkTypeUpdate" was null or undefined when calling updateLinkType().');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/link-types/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.LinkTypeUpdateToJSON)(requestParameters['linkTypeUpdate']),
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.LinkTypeSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it.
     * Update existing link type.
     */
    updateLinkType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateLinkTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Used to update a single existing link.
     * Update an existing link between transactions.
     */
    updateTransactionLinkRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling updateTransactionLink().');
            }
            if (requestParameters['transactionLinkUpdate'] == null) {
                throw new runtime.RequiredError('transactionLinkUpdate', 'Required parameter "transactionLinkUpdate" was null or undefined when calling updateTransactionLink().');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/transaction-links/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.TransactionLinkUpdateToJSON)(requestParameters['transactionLinkUpdate']),
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.TransactionLinkSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Used to update a single existing link.
     * Update an existing link between transactions.
     */
    updateTransactionLink(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateTransactionLinkRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}
exports.LinksApi = LinksApi;
