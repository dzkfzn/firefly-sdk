"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v6.2.21
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2025-07-18T05:50:30+00:00 Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that.
 *
 * The version of the OpenAPI document: v6.2.21
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhooksApi = void 0;
const runtime = __importStar(require("../runtime"));
const index_1 = require("../models/index");
/**
 *
 */
class WebhooksApi extends runtime.BaseAPI {
    /**
     * Delete a webhook.
     * Delete a webhook.
     */
    deleteWebhookRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling deleteWebhook().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.VoidApiResponse(response);
        });
    }
    /**
     * Delete a webhook.
     * Delete a webhook.
     */
    deleteWebhook(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteWebhookRaw(requestParameters, initOverrides);
        });
    }
    /**
     * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
     * Delete a webhook message.
     */
    deleteWebhookMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling deleteWebhookMessage().');
            }
            if (requestParameters['messageId'] == null) {
                throw new runtime.RequiredError('messageId', 'Required parameter "messageId" was null or undefined when calling deleteWebhookMessage().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}/messages/{messageId}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            urlPath = urlPath.replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId'])));
            const response = yield this.request({
                path: urlPath,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.VoidApiResponse(response);
        });
    }
    /**
     * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
     * Delete a webhook message.
     */
    deleteWebhookMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteWebhookMessageRaw(requestParameters, initOverrides);
        });
    }
    /**
     * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
     * Delete a webhook attempt.
     */
    deleteWebhookMessageAttemptRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling deleteWebhookMessageAttempt().');
            }
            if (requestParameters['messageId'] == null) {
                throw new runtime.RequiredError('messageId', 'Required parameter "messageId" was null or undefined when calling deleteWebhookMessageAttempt().');
            }
            if (requestParameters['attemptId'] == null) {
                throw new runtime.RequiredError('attemptId', 'Required parameter "attemptId" was null or undefined when calling deleteWebhookMessageAttempt().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            urlPath = urlPath.replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId'])));
            urlPath = urlPath.replace(`{${"attemptId"}}`, encodeURIComponent(String(requestParameters['attemptId'])));
            const response = yield this.request({
                path: urlPath,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.VoidApiResponse(response);
        });
    }
    /**
     * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
     * Delete a webhook attempt.
     */
    deleteWebhookMessageAttempt(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteWebhookMessageAttemptRaw(requestParameters, initOverrides);
        });
    }
    /**
     * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
     * Get a single message from a webhook.
     */
    getSingleWebhookMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling getSingleWebhookMessage().');
            }
            if (requestParameters['messageId'] == null) {
                throw new runtime.RequiredError('messageId', 'Required parameter "messageId" was null or undefined when calling getSingleWebhookMessage().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}/messages/{messageId}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            urlPath = urlPath.replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId'])));
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.WebhookMessageSingleFromJSON)(jsonValue));
        });
    }
    /**
     * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
     * Get a single message from a webhook.
     */
    getSingleWebhookMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getSingleWebhookMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
     * Get a single failed attempt from a single webhook message.
     */
    getSingleWebhookMessageAttemptRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling getSingleWebhookMessageAttempt().');
            }
            if (requestParameters['messageId'] == null) {
                throw new runtime.RequiredError('messageId', 'Required parameter "messageId" was null or undefined when calling getSingleWebhookMessageAttempt().');
            }
            if (requestParameters['attemptId'] == null) {
                throw new runtime.RequiredError('attemptId', 'Required parameter "attemptId" was null or undefined when calling getSingleWebhookMessageAttempt().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            urlPath = urlPath.replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId'])));
            urlPath = urlPath.replace(`{${"attemptId"}}`, encodeURIComponent(String(requestParameters['attemptId'])));
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.WebhookAttemptSingleFromJSON)(jsonValue));
        });
    }
    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
     * Get a single failed attempt from a single webhook message.
     */
    getSingleWebhookMessageAttempt(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getSingleWebhookMessageAttemptRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets all info of a single webhook.
     * Get a single webhook.
     */
    getWebhookRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling getWebhook().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.WebhookSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Gets all info of a single webhook.
     * Get a single webhook.
     */
    getWebhook(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getWebhookRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
     * Get all the failed attempts of a single webhook message.
     */
    getWebhookMessageAttemptsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling getWebhookMessageAttempts().');
            }
            if (requestParameters['messageId'] == null) {
                throw new runtime.RequiredError('messageId', 'Required parameter "messageId" was null or undefined when calling getWebhookMessageAttempts().');
            }
            const queryParameters = {};
            if (requestParameters['limit'] != null) {
                queryParameters['limit'] = requestParameters['limit'];
            }
            if (requestParameters['page'] != null) {
                queryParameters['page'] = requestParameters['page'];
            }
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}/messages/{messageId}/attempts`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            urlPath = urlPath.replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters['messageId'])));
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.WebhookAttemptArrayFromJSON)(jsonValue));
        });
    }
    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
     * Get all the failed attempts of a single webhook message.
     */
    getWebhookMessageAttempts(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getWebhookMessageAttemptsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
     * Get all the messages of a single webhook.
     */
    getWebhookMessagesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling getWebhookMessages().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}/messages`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.WebhookMessageArrayFromJSON)(jsonValue));
        });
    }
    /**
     * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
     * Get all the messages of a single webhook.
     */
    getWebhookMessages(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getWebhookMessagesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * List all the user\'s webhooks.
     * List all webhooks.
     */
    listWebhookRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters['limit'] != null) {
                queryParameters['limit'] = requestParameters['limit'];
            }
            if (requestParameters['page'] != null) {
                queryParameters['page'] = requestParameters['page'];
            }
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks`;
            const response = yield this.request({
                path: urlPath,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.WebhookArrayFromJSON)(jsonValue));
        });
    }
    /**
     * List all the user\'s webhooks.
     * List all webhooks.
     */
    listWebhook() {
        return __awaiter(this, arguments, void 0, function* (requestParameters = {}, initOverrides) {
            const response = yield this.listWebhookRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret.
     * Store a new webhook
     */
    storeWebhookRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['webhookStore'] == null) {
                throw new runtime.RequiredError('webhookStore', 'Required parameter "webhookStore" was null or undefined when calling storeWebhook().');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks`;
            const response = yield this.request({
                path: urlPath,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.WebhookStoreToJSON)(requestParameters['webhookStore']),
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.WebhookSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret.
     * Store a new webhook
     */
    storeWebhook(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.storeWebhookRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
     * Submit messages for a webhook.
     */
    submitWebookRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling submitWebook().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}/submit`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.VoidApiResponse(response);
        });
    }
    /**
     * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
     * Submit messages for a webhook.
     */
    submitWebook(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.submitWebookRaw(requestParameters, initOverrides);
        });
    }
    /**
     * This endpoint will execute this webhook for a given transaction ID. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
     * Trigger webhook for a given transaction.
     */
    triggerTransactionWebhookRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling triggerTransactionWebhook().');
            }
            if (requestParameters['transactionId'] == null) {
                throw new runtime.RequiredError('transactionId', 'Required parameter "transactionId" was null or undefined when calling triggerTransactionWebhook().');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}/trigger-transaction/{transactionId}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            urlPath = urlPath.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters['transactionId'])));
            const response = yield this.request({
                path: urlPath,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new runtime.VoidApiResponse(response);
        });
    }
    /**
     * This endpoint will execute this webhook for a given transaction ID. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
     * Trigger webhook for a given transaction.
     */
    triggerTransactionWebhook(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.triggerTransactionWebhookRaw(requestParameters, initOverrides);
        });
    }
    /**
     * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
     * Update existing webhook.
     */
    updateWebhookRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters['id'] == null) {
                throw new runtime.RequiredError('id', 'Required parameter "id" was null or undefined when calling updateWebhook().');
            }
            if (requestParameters['webhookUpdate'] == null) {
                throw new runtime.RequiredError('webhookUpdate', 'Required parameter "webhookUpdate" was null or undefined when calling updateWebhook().');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (requestParameters['xTraceId'] != null) {
                headerParameters['X-Trace-Id'] = String(requestParameters['xTraceId']);
            }
            if (this.configuration && this.configuration.accessToken) {
                // oauth required
                headerParameters["Authorization"] = yield this.configuration.accessToken("firefly_iii_auth", []);
            }
            if (this.configuration && this.configuration.accessToken) {
                const token = this.configuration.accessToken;
                const tokenString = yield token("local_bearer_auth", []);
                if (tokenString) {
                    headerParameters["Authorization"] = `Bearer ${tokenString}`;
                }
            }
            let urlPath = `/v1/webhooks/{id}`;
            urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
            const response = yield this.request({
                path: urlPath,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.WebhookUpdateToJSON)(requestParameters['webhookUpdate']),
            }, initOverrides);
            return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.WebhookSingleFromJSON)(jsonValue));
        });
    }
    /**
     * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
     * Update existing webhook.
     */
    updateWebhook(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateWebhookRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}
exports.WebhooksApi = WebhooksApi;
